// Do not edit this file; automatically generated by build.py.
'use strict';

// Copyright 2012 Google Inc.  Apache License 2.0
Blockly.C = new Blockly.Generator("C");
Blockly
    .C
    .addReservedWords(
        "Blockly,break,case,catch,continue,debugger,default,delete,do,else,finally,for," +
        "function,if,in,instanceof,new,return,switch,this,throw,try,typeof,var,void,whi" +
        "le,with,class,enum,export,extends,import,super,implements,interface,let,packag" +
        "e,private,protected,public,static,yield,const,null,true,false,Array,ArrayBuffe" +
        "r,Boolean,Date,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Error" +
        ",eval,EvalError,Float32Array,Float64Array,Function,Infinity,Int16Array,Int32Ar" +
        "ray,Int8Array,isFinite,isNaN,Iterator,JSON,Math,NaN,Number,Object,parseFloat,p" +
        "arseInt,RangeError,ReferenceError,RegExp,StopIteration,String,SyntaxError,Type" +
        "Error,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray,undefined,uneval,UR" +
        "IError,applicationCache,closed,Components,content,_content,controllers,crypto," +
        "defaultStatus,dialogArguments,directories,document,frameElement,frames,fullScr" +
        "een,globalStorage,history,innerHeight,innerWidth,length,location,locationbar,l" +
        "ocalStorage,menubar,messageManager,mozAnimationStartTime,mozInnerScreenX,mozIn" +
        "nerScreenY,mozPaintCount,name,navigator,opener,outerHeight,outerWidth,pageXOff" +
        "set,pageYOffset,parent,performance,personalbar,pkcs11,returnValue,screen,scree" +
        "nX,screenY,scrollbars,scrollMaxX,scrollMaxY,scrollX,scrollY,self,sessionStorag" +
        "e,sidebar,status,statusbar,toolbar,top,URL,window,addEventListener,alert,atob," +
        "back,blur,btoa,captureEvents,clearImmediate,clearInterval,clearTimeout,close,c" +
        "onfirm,disableExternalCapture,dispatchEvent,dump,enableExternalCapture,escape," +
        "find,focus,forward,GeckoActiveXObject,getAttention,getAttentionWithCycleCount," +
        "getComputedStyle,getSelection,home,matchMedia,maximize,minimize,moveBy,moveTo," +
        "mozRequestAnimationFrame,open,openDialog,postMessage,print,prompt,QueryInterfa" +
        "ce,releaseEvents,removeEventListener,resizeBy,resizeTo,restore,routeEvent,scro" +
        "ll,scrollBy,scrollByLines,scrollByPages,scrollTo,setCursor,setImmediate,setInt" +
        "erval,setResizable,setTimeout,showModalDialog,sizeToContent,stop,unescape,upda" +
        "teCommands,XPCNativeWrapper,XPCSafeJSObjectWrapper,onabort,onbeforeunload,onbl" +
        "ur,onchange,onclick,onclose,oncontextmenu,ondevicemotion,ondeviceorientation,o" +
        "ndragdrop,onerror,onfocus,onhashchange,onkeydown,onkeypress,onkeyup,onload,onm" +
        "ousedown,onmousemove,onmouseout,onmouseover,onmouseup,onmozbeforepaint,onpaint" +
        ",onpopstate,onreset,onresize,onscroll,onselect,onsubmit,onunload,onpageshow,on" +
        "pagehide,Image,Option,Worker,Event,Range,File,FileReader,Blob,BlobBuilder,Attr" +
        ",CDATASection,CharacterData,Comment,console,DocumentFragment,DocumentType,DomC" +
        "onfiguration,DOMError,DOMErrorHandler,DOMException,DOMImplementation,DOMImplem" +
        "entationList,DOMImplementationRegistry,DOMImplementationSource,DOMLocator,DOMO" +
        "bject,DOMString,DOMStringList,DOMTimeStamp,DOMUserData,Entity,EntityReference," +
        "MediaQueryList,MediaQueryListListener,NameList,NamedNodeMap,Node,NodeFilter,No" +
        "deIterator,NodeList,Notation,Plugin,PluginArray,ProcessingInstruction,SharedWo" +
        "rker,Text,TimeRanges,Treewalker,TypeInfo,UserDataHandler,Worker,WorkerGlobalSc" +
        "ope,HTMLDocument,HTMLElement,HTMLAnchorElement,HTMLAppletElement,HTMLAudioElem" +
        "ent,HTMLAreaElement,HTMLBaseElement,HTMLBaseFontElement,HTMLBodyElement,HTMLBR" +
        "Element,HTMLButtonElement,HTMLCanvasElement,HTMLDirectoryElement,HTMLDivElemen" +
        "t,HTMLDListElement,HTMLEmbedElement,HTMLFieldSetElement,HTMLFontElement,HTMLFo" +
        "rmElement,HTMLFrameElement,HTMLFrameSetElement,HTMLHeadElement,HTMLHeadingElem" +
        "ent,HTMLHtmlElement,HTMLHRElement,HTMLIFrameElement,HTMLImageElement,HTMLInput" +
        "Element,HTMLKeygenElement,HTMLLabelElement,HTMLLIElement,HTMLLinkElement,HTMLM" +
        "apElement,HTMLMenuElement,HTMLMetaElement,HTMLModElement,HTMLObjectElement,HTM" +
        "LOListElement,HTMLOptGroupElement,HTMLOptionElement,HTMLOutputElement,HTMLPara" +
        "graphElement,HTMLParamElement,HTMLPreElement,HTMLQuoteElement,HTMLScriptElemen" +
        "t,HTMLSelectElement,HTMLSourceElement,HTMLSpanElement,HTMLStyleElement,HTMLTab" +
        "leElement,HTMLTableCaptionElement,HTMLTableCellElement,HTMLTableDataCellElemen" +
        "t,HTMLTableHeaderCellElement,HTMLTableColElement,HTMLTableRowElement,HTMLTable" +
        "SectionElement,HTMLTextAreaElement,HTMLTimeElement,HTMLTitleElement,HTMLTrackE" +
        "lement,HTMLUListElement,HTMLUnknownElement,HTMLVideoElement,HTMLCanvasElement," +
        "CanvasRenderingContext2D,CanvasGradient,CanvasPattern,TextMetrics,ImageData,Ca" +
        "nvasPixelArray,HTMLAudioElement,HTMLVideoElement,NotifyAudioAvailableEvent,HTM" +
        "LCollection,HTMLAllCollection,HTMLFormControlsCollection,HTMLOptionsCollection" +
        ",HTMLPropertiesCollection,DOMTokenList,DOMSettableTokenList,DOMStringMap,Radio" +
        "NodeList,SVGDocument,SVGElement,SVGAElement,SVGAltGlyphElement,SVGAltGlyphDefE" +
        "lement,SVGAltGlyphItemElement,SVGAnimationElement,SVGAnimateElement,SVGAnimate" +
        "ColorElement,SVGAnimateMotionElement,SVGAnimateTransformElement,SVGSetElement," +
        "SVGCircleElement,SVGClipPathElement,SVGColorProfileElement,SVGCursorElement,SV" +
        "GDefsElement,SVGDescElement,SVGEllipseElement,SVGFilterElement,SVGFilterPrimit" +
        "iveStandardAttributes,SVGFEBlendElement,SVGFEColorMatrixElement,SVGFEComponent" +
        "TransferElement,SVGFECompositeElement,SVGFEConvolveMatrixElement,SVGFEDiffuseL" +
        "ightingElement,SVGFEDisplacementMapElement,SVGFEDistantLightElement,SVGFEFlood" +
        "Element,SVGFEGaussianBlurElement,SVGFEImageElement,SVGFEMergeElement,SVGFEMerg" +
        "eNodeElement,SVGFEMorphologyElement,SVGFEOffsetElement,SVGFEPointLightElement," +
        "SVGFESpecularLightingElement,SVGFESpotLightElement,SVGFETileElement,SVGFETurbu" +
        "lenceElement,SVGComponentTransferFunctionElement,SVGFEFuncRElement,SVGFEFuncGE" +
        "lement,SVGFEFuncBElement,SVGFEFuncAElement,SVGFontElement,SVGFontFaceElement,S" +
        "VGFontFaceFormatElement,SVGFontFaceNameElement,SVGFontFaceSrcElement,SVGFontFa" +
        "ceUriElement,SVGForeignObjectElement,SVGGElement,SVGGlyphElement,SVGGlyphRefEl" +
        "ement,SVGGradientElement,SVGLinearGradientElement,SVGRadialGradientElement,SVG" +
        "HKernElement,SVGImageElement,SVGLineElement,SVGMarkerElement,SVGMaskElement,SV" +
        "GMetadataElement,SVGMissingGlyphElement,SVGMPathElement,SVGPathElement,SVGPatt" +
        "ernElement,SVGPolylineElement,SVGPolygonElement,SVGRectElement,SVGScriptElemen" +
        "t,SVGStopElement,SVGStyleElement,SVGSVGElement,SVGSwitchElement,SVGSymbolEleme" +
        "nt,SVGTextElement,SVGTextPathElement,SVGTitleElement,SVGTRefElement,SVGTSpanEl" +
        "ement,SVGUseElement,SVGViewElement,SVGVKernElement,SVGAngle,SVGColor,SVGICCCol" +
        "or,SVGElementInstance,SVGElementInstanceList,SVGLength,SVGLengthList,SVGMatrix" +
        ",SVGNumber,SVGNumberList,SVGPaint,SVGPoint,SVGPointList,SVGPreserveAspectRatio" +
        ",SVGRect,SVGStringList,SVGTransform,SVGTransformList,SVGAnimatedAngle,SVGAnima" +
        "tedBoolean,SVGAnimatedEnumeration,SVGAnimatedInteger,SVGAnimatedLength,SVGAnim" +
        "atedLengthList,SVGAnimatedNumber,SVGAnimatedNumberList,SVGAnimatedPreserveAspe" +
        "ctRatio,SVGAnimatedRect,SVGAnimatedString,SVGAnimatedTransformList,SVGPathSegL" +
        "ist,SVGPathSeg,SVGPathSegArcAbs,SVGPathSegArcRel,SVGPathSegClosePath,SVGPathSe" +
        "gCurvetoCubicAbs,SVGPathSegCurvetoCubicRel,SVGPathSegCurvetoCubicSmoothAbs,SVG" +
        "PathSegCurvetoCubicSmoothRel,SVGPathSegCurvetoQuadraticAbs,SVGPathSegCurvetoQu" +
        "adraticRel,SVGPathSegCurvetoQuadraticSmoothAbs,SVGPathSegCurvetoQuadraticSmoot" +
        "hRel,SVGPathSegLinetoAbs,SVGPathSegLinetoHorizontalAbs,SVGPathSegLinetoHorizon" +
        "talRel,SVGPathSegLinetoRel,SVGPathSegLinetoVerticalAbs,SVGPathSegLinetoVertica" +
        "lRel,SVGPathSegMovetoAbs,SVGPathSegMovetoRel,ElementTimeControl,TimeEvent,SVGA" +
        "nimatedPathData,SVGAnimatedPoints,SVGColorProfileRule,SVGCSSRule,SVGExternalRe" +
        "sourcesRequired,SVGFitToViewBox,SVGLangSpace,SVGLocatable,SVGRenderingIntent,S" +
        "VGStylable,SVGTests,SVGTextContentElement,SVGTextPositioningElement,SVGTransfo" +
        "rmable,SVGUnitTypes,SVGURIReference,SVGViewSpec,SVGZoomAndPan"
    );
Blockly.C.ORDER_ATOMIC             = 0;
Blockly.C.ORDER_NEW                = 1.1;
Blockly.C.ORDER_MEMBER             = 1.2;
Blockly.C.ORDER_FUNCTION_CALL      = 2;
Blockly.C.ORDER_INCREMENT          = 3;
Blockly.C.ORDER_DECREMENT          = 3;
Blockly.C.ORDER_BITWISE_NOT        = 4.1;
Blockly.C.ORDER_UNARY_PLUS         = 4.2;
Blockly.C.ORDER_UNARY_NEGATION     = 4.3;
Blockly.C.ORDER_LOGICAL_NOT        = 4.4;
Blockly.C.ORDER_TYPEOF             = 4.5;
Blockly.C.ORDER_VOID               = 4.6;
Blockly.C.ORDER_DELETE             = 4.7;
Blockly.C.ORDER_DIVISION           = 5.1;
Blockly.C.ORDER_MULTIPLICATION     = 5.2;
Blockly.C.ORDER_MODULUS            = 5.3;
Blockly.C.ORDER_SUBTRACTION        = 6.1;
Blockly.C.ORDER_ADDITION           = 6.2;
Blockly.C.ORDER_BITWISE_SHIFT      = 7;
Blockly.C.ORDER_RELATIONAL         = 8;
Blockly.C.ORDER_IN                 = 8;
Blockly.C.ORDER_INSTANCEOF         = 8;
Blockly.C.ORDER_EQUALITY           = 9;
Blockly.C.ORDER_BITWISE_AND        = 10;
Blockly.C.ORDER_BITWISE_XOR        = 11;
Blockly.C.ORDER_BITWISE_OR         = 12;
Blockly.C.ORDER_LOGICAL_AND        = 13;
Blockly.C.ORDER_LOGICAL_OR         = 14;
Blockly.C.ORDER_CONDITIONAL        = 15;
Blockly.C.ORDER_ASSIGNMENT         = 16;
Blockly.C.ORDER_COMMA              = 17;
Blockly.C.ORDER_NONE               = 99;
Blockly.C.ORDER_OVERRIDES          = [
    [
        Blockly.C.ORDER_FUNCTION_CALL, Blockly.C.ORDER_MEMBER
    ],
    [
        Blockly.C.ORDER_FUNCTION_CALL, Blockly.C.ORDER_FUNCTION_CALL
    ],
    [
        Blockly.C.ORDER_MEMBER, Blockly.C.ORDER_MEMBER
    ],
    [
        Blockly.C.ORDER_MEMBER, Blockly.C.ORDER_FUNCTION_CALL
    ],
    [
        Blockly.C.ORDER_LOGICAL_NOT, Blockly.C.ORDER_LOGICAL_NOT
    ],
    [
        Blockly.C.ORDER_MULTIPLICATION, Blockly.C.ORDER_MULTIPLICATION
    ],
    [
        Blockly.C.ORDER_ADDITION, Blockly.C.ORDER_ADDITION
    ],
    [
        Blockly.C.ORDER_LOGICAL_AND, Blockly.C.ORDER_LOGICAL_AND
    ],
    [
        Blockly.C.ORDER_LOGICAL_OR, Blockly.C.ORDER_LOGICAL_OR
    ]
];
Blockly.C.init                     = function (a) {
    Blockly.C.definitions_      = Object.create(null);
    Blockly.C.functionNames_    = Object.create(null);
    Blockly.C.variableDB_
        ? Blockly
            .C
            .variableDB_
            .reset()
        : Blockly.C.variableDB_ = new Blockly.Names(Blockly.C.RESERVED_WORDS_);
    var b = [];
    a = a.variableList;
    if (a.length) {
        for (var c = 0; c < a.length; c++) 
            b[c] = Blockly
                .C
                .variableDB_
                .getName(a[c], Blockly.Variables.NAME_TYPE);
        Blockly.C.definitions_.variables = "var " + b.join(", ") + ";"
    }
};
Blockly.C.finish                   = function (a) {
    var b = [],
        c;
    for (c in Blockly.C.definitions_) 
        b.push(Blockly.C.definitions_[c]);
    delete Blockly.C.definitions_;
    delete Blockly.C.functionNames_;
    Blockly
        .C
        .variableDB_
        .reset();
    return b.join("\n\n") + "\n\n\n" + a
};
Blockly.C.scrubNakedValue          = function (a) {
    return a + ";\n"
};
Blockly.C.quote_                   = function (a) {
    a = a
        .replace(/\\/g, "\\\\")
        .replace(/\n/g, "\\\n")
        .replace(/'/g, "\\'");
    return "'" + a + "'"
};
Blockly.C.scrub_                   = function (a, b) {
    var c = "";
    if (!a.outputConnection || !a.outputConnection.targetConnection) {
        var d = a.getCommentText();
        (d = Blockly.utils.wrap(d, Blockly.C.COMMENT_WRAP - 3)) && (
            c = a.getProcedureDef
                ? c + ("/**\n" + Blockly.C.prefixLines(d + "\n", " * ") + " */\n")
                : c + Blockly.C.prefixLines(d + "\n", "// ")
        );
        for (var e = 0; e < a.inputList.length; e++) 
            a
                .inputList[e]
                .type == Blockly.INPUT_VALUE && (d = a.inputList[e].connection.targetBlock()) && (
                    d = Blockly.C.allNestedComments(d)
                ) && (c += Blockly.C.prefixLines(d, "// "))
        }
    e = a.nextConnection && a
        .nextConnection
        .targetBlock();
    e = Blockly
        .C
        .blockToCode(e);
    return c + b + e
};
Blockly.C.getAdjusted              = function (a, b, c, d, e) {
    c = c || 0;
    e = e || Blockly.C.ORDER_NONE;
    a.workspace.options.oneBasedIndex && c--;
    var f = a.workspace.options.oneBasedIndex
        ? "1"
        : "0";
    a = 0 < c
        ? Blockly
            .C
            .valueToCode(a, b, Blockly.C.ORDER_ADDITION) || f
        : 0 > c
            ? Blockly
                .C
                .valueToCode(a, b, Blockly.C.ORDER_SUBTRACTION) || f
            : d
                ? Blockly
                    .C
                    .valueToCode(a, b, Blockly.C.ORDER_UNARY_NEGATION) || f
                : Blockly
                    .C
                    .valueToCode(a, b, e) || f;
    if (Blockly.isNumber(a)) 
        a = parseFloat(a) + c,
        d && (a = -a);
    else {
        if (0 < c) {
            a = a + " + " + c;
            var g = Blockly.C.ORDER_ADDITION
        } else 
            0 > c && (a = a + " - " + -c, g = Blockly.C.ORDER_SUBTRACTION);
        d && (
            a = c
                ? "-(" + a + ")"
                : "-" + a,
            g = Blockly.C.ORDER_UNARY_NEGATION
        );
        g = Math.floor(g);
        e = Math.floor(e);
        g && e >= g && (a = "(" + a + ")")
    }
    return a
};
Blockly.C.lists                    = {};
Blockly.C.lists_create_empty       = function (a) {
    return ["[]", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.lists_create_with        = function (a) {
    for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) 
        b[c] = Blockly
            .C
            .valueToCode(a, "ADD" + c, Blockly.C.ORDER_COMMA) || "null";
    return [
        "[" + b.join(", ") + "]",
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.lists_repeat             = function (a) {
    var b = Blockly
            .C
            .provideFunction_("listsRepeat", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(value, n) {",
                "  var array = [];",
                "  for (var i = 0; i < n; i++) {",
                "    array[i] = value;",
                "  }",
                "  return array;",
                "}"
            ]),
        c = Blockly
            .C
            .valueToCode(a, "ITEM", Blockly.C.ORDER_COMMA) || "null";
    a = Blockly
        .C
        .valueToCode(a, "NUM", Blockly.C.ORDER_COMMA) || "0";
    return [
        b + "(" + c + ", " + a + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.lists_length             = function (a) {
    return [
        (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "[]") +
                ".length",
        Blockly.C.ORDER_MEMBER
    ]
};
Blockly.C.lists_isEmpty            = function (a) {
    return [
        "!" + (
            Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "[]"
        ) + ".length",
        Blockly.C.ORDER_LOGICAL_NOT
    ]
};
Blockly.C.lists_indexOf            = function (a) {
    var b = "FIRST" == a.getFieldValue("END")
            ? "indexOf"
            : "lastIndexOf",
        c = Blockly
            .C
            .valueToCode(a, "FIND", Blockly.C.ORDER_NONE) || "''",
        b = (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "[]") + "." +
                b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex
        ? [
            b + " + 1",
            Blockly.C.ORDER_ADDITION
        ]
        : [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_getIndex           = function (a) {
    var b = a.getFieldValue("MODE") || "GET",
        c = a.getFieldValue("WHERE") || "FROM_START";
    var d = Blockly
        .C
        .valueToCode(
            a,
            "VALUE",
            "RANDOM" == c
                ? Blockly.C.ORDER_COMMA
                : Blockly.C.ORDER_MEMBER
        ) || "[]";
    switch (c) {
        case "FIRST":
            if ("GET" == b) 
                return [
                    d + "[0]",
                    Blockly.C.ORDER_MEMBER
                ];
            if ("GET_REMOVE" == b) 
                return [
                    d + ".shift()",
                    Blockly.C.ORDER_MEMBER
                ];
            if ("REMOVE" == b) 
                return d + ".shift();\n";
            break;
        case "LAST":
            if ("GET" == b) 
                return [
                    d + ".slice(-1)[0]",
                    Blockly.C.ORDER_MEMBER
                ];
            if ("GET_REMOVE" == b) 
                return [
                    d + ".pop()",
                    Blockly.C.ORDER_MEMBER
                ];
            if ("REMOVE" == b) 
                return d + ".pop();\n";
            break;
        case "FROM_START":
            a = Blockly
                .C
                .getAdjusted(a, "AT");
            if ("GET" == b) 
                return [
                    d + "[" + a + "]",
                    Blockly.C.ORDER_MEMBER
                ];
            if ("GET_REMOVE" == b) 
                return [
                    d + ".splice(" + a + ", 1)[0]",
                    Blockly.C.ORDER_FUNCTION_CALL
                ];
            if ("REMOVE" == b) 
                return d + ".splice(" + a + ", 1);\n";
            break;
        case "FROM_END":
            a = Blockly
                .C
                .getAdjusted(a, "AT", 1, !0);
            if ("GET" == b) 
                return [
                    d + ".slice(" + a + ")[0]",
                    Blockly.C.ORDER_FUNCTION_CALL
                ];
            if ("GET_REMOVE" == b) 
                return [
                    d + ".splice(" + a + ", 1)[0]",
                    Blockly.C.ORDER_FUNCTION_CALL
                ];
            if ("REMOVE" == b) 
                return d + ".splice(" + a + ", 1);";
            break;
        case "RANDOM":
            d = Blockly
                .C
                .provideFunction_("listsGetRandomItem", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(list, remove) {",
                    "  var x = Math.floor(Math.random() * list.length);",
                    "  if (remove) {",
                    "    return list.splice(x, 1)[0];",
                    "  } else {",
                    "    return list[x];",
                    "  }",
                    "}"
                ]) + "(" + d + ", " + (
                "GET" != b
            ) + ")";
            if ("GET" == b || "GET_REMOVE" == b) 
                return [d, Blockly.C.ORDER_FUNCTION_CALL];
            if ("REMOVE" == b) 
                return d + ";\n"
        }
    throw "Unhandled combination (lists_getIndex).";
};
Blockly.C.lists_setIndex           = function (a) {
    function b() {
        if (c.match(/^\w+$/)) 
            return "";
        var a = Blockly
                .C
                .variableDB_
                .getDistinctName("tmpList", Blockly.Variables.NAME_TYPE),
            b = "var " + a + " = " + c + ";\n";
        c = a;
        return b
    }
    var c = Blockly
            .C
            .valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]",
        d = a.getFieldValue("MODE") || "GET",
        e = a.getFieldValue("WHERE") || "FROM_START",
        f = Blockly
            .C
            .valueToCode(a, "TO", Blockly.C.ORDER_ASSIGNMENT) || "null";
    switch (e) {
        case "FIRST":
            if ("SET" == d) 
                return c + "[0] = " + f + ";\n";
            if ("INSERT" == d) 
                return c + ".unshift(" + f + ");\n";
            break;
        case "LAST":
            if ("SET" == d) 
                return a = b(),
                a + (c + "[" + c + ".length - 1] = " + f + ";\n");
            if ("INSERT" == d) 
                return c + ".push(" + f + ");\n";
            break;
        case "FROM_START":
            e = Blockly
                .C
                .getAdjusted(a, "AT");
            if ("SET" == d) 
                return c + "[" + e + "] = " + f + ";\n";
            if ("INSERT" == d) 
                return c + ".splice(" + e + ", 0, " + f + ");\n";
            break;
        case "FROM_END":
            e = Blockly
                .C
                .getAdjusted(a, "AT", 1, !1, Blockly.C.ORDER_SUBTRACTION);
            a = b();
            if ("SET" == d) 
                return a + (c + "[" + c + ".length - " + e + "] = " + f + ";\n");
            if ("INSERT" == d) 
                return a + (c + ".splice(" + c + ".length - " + e + ", 0, " + f + ");\n");
            break;
        case "RANDOM":
            a = b();
            e = Blockly
                .C
                .variableDB_
                .getDistinctName("tmpX", Blockly.Variables.NAME_TYPE);
            a += "var " + e + " = Math.floor(Math.random() * " + c + ".length);\n";
            if ("SET" == d) 
                return a + (c + "[" + e + "] = " + f + ";\n");
            if ("INSERT" == d) 
                return a + (c + ".splice(" + e + ", 0, " + f + ");\n")
        }
    throw "Unhandled combination (lists_setIndex).";
};
Blockly.C.lists.getIndex_          = function (a, b, c) {
    return "FIRST" == b
        ? "0"
        : "FROM_END" == b
            ? a + ".length - 1 - " + c
            : "LAST" == b
                ? a + ".length - 1"
                : c
};
Blockly.C.lists_getSublist         = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2");
    if ("FIRST" == c && "LAST" == d) 
        var e = b + ".slice(0)";
    else if (b.match(/^\w+$/) || "FROM_END" != c && "FROM_START" == d) {
        switch (c) {
            case "FROM_START":
                e = Blockly
                    .C
                    .getAdjusted(a, "AT1");
                break;
            case "FROM_END":
                e = Blockly
                    .C
                    .getAdjusted(a, "AT1", 1, !1, Blockly.C.ORDER_SUBTRACTION);
                e = b + ".length - " + e;
                break;
            case "FIRST":
                e = "0";
                break;
            default:
                throw "Unhandled option (lists_getSublist).";
        }
        switch (d) {
            case "FROM_START":
                a = Blockly
                    .C
                    .getAdjusted(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly
                    .C
                    .getAdjusted(a, "AT2", 0, !1, Blockly.C.ORDER_SUBTRACTION);
                a = b + ".length - " + a;
                break;
            case "LAST":
                a = b + ".length";
                break;
            default:
                throw "Unhandled option (lists_getSublist).";
        }
        e = b + ".slice(" + e + ", " + a + ")"
    } else {
        e = Blockly
            .C
            .getAdjusted(a, "AT1");
        a = Blockly
            .C
            .getAdjusted(a, "AT2");
        var f = Blockly.C.lists.getIndex_;
        var g = {
            FIRST     : "First",
            FROM_END  : "FromEnd",
            FROM_START: "FromStart",
            LAST      : "Last"
        };
        f = Blockly
            .C
            .provideFunction_("subsequence" + g[c] + g[d], [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + (
                    "FROM_END" == c || "FROM_START" == c
                        ? ", at1"
                        : ""
                ) + (
                    "FROM_END" == d || "FROM_START" == d
                        ? ", at2"
                        : ""
                ) + ") {",
                "  var start = " + f("sequence", c, "at1") + ";",
                "  var end = " + f("sequence", d, "at2") + " + 1;",
                "  return sequence.slice(start, end);",
                "}"
            ]);
        e = f + "(" + b + (
            "FROM_END" == c || "FROM_START" == c
                ? ", " + e
                : ""
        ) + (
            "FROM_END" == d || "FROM_START" == d
                ? ", " + a
                : ""
        ) + ")"
    }
    return [e, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.lists_sort               = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "LIST", Blockly.C.ORDER_FUNCTION_CALL) || "[]",
        c = "1" === a.getFieldValue("DIRECTION")
            ? 1
            : -1;
    a = a.getFieldValue("TYPE");
    var d = Blockly
        .C
        .provideFunction_("listsGetSortCompare", [
            "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(type, direction) {",
            "  var compareFuncs = {",
            '    "NUMERIC": function(a, b) {',
            "        return parseFloat(a) - parseFloat(b); },",
            '    "TEXT": function(a, b) {',
            "        return a.toString() > b.toString() ? 1 : -1; },",
            '    "IGNORE_CASE": function(a, b) {',
            "        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -" +
                    "1; },",
            "  };",
            "  var compare = compareFuncs[type];",
            "  return function(a, b) { return compare(a, b) * direction; }",
            "}"
        ]);
    return [
        b + ".slice().sort(" + d + '("' + a + '", ' + c + "))",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.lists_split              = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "INPUT", Blockly.C.ORDER_MEMBER),
        c = Blockly
            .C
            .valueToCode(a, "DELIM", Blockly.C.ORDER_NONE) || "''";
    a = a.getFieldValue("MODE");
    if ("SPLIT" == a) 
        b || (b = "''"),
        a = "split";
    else if ("JOIN" == a) 
        b || (b = "[]"),
        a = "join";
    else 
        throw "Unknown mode: " + a;
    return [
        b + "." + a + "(" + c + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.lists_reverse            = function (a) {
    return [
        (Blockly.C.valueToCode(a, "LIST", Blockly.C.ORDER_FUNCTION_CALL) || "[]") + ".s" +
                "lice().reverse()",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.math                     = {};
Blockly.C.math_number              = function (a) {
    return [
        parseFloat(a.getFieldValue("NUM")),
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.math_arithmetic          = function (a) {
    var b = {
            ADD     : [
                " + ", Blockly.C.ORDER_ADDITION
            ],
            DIVIDE  : [
                " / ", Blockly.C.ORDER_DIVISION
            ],
            MINUS   : [
                " - ", Blockly.C.ORDER_SUBTRACTION
            ],
            MULTIPLY: [
                " * ", Blockly.C.ORDER_MULTIPLICATION
            ],
            POWER   : [null, Blockly.C.ORDER_COMMA]
        }[a.getFieldValue("OP")],
        c = b[0],
        b = b[1],
        d = Blockly
            .C
            .valueToCode(a, "A", b) || "0";
    a = Blockly
        .C
        .valueToCode(a, "B", b) || "0";
    return c
        ? [
            d + c + a,
            b
        ]
        : [
            "Math.pow(" + d + ", " + a + ")",
            Blockly.C.ORDER_FUNCTION_CALL
        ]
};
Blockly.C.math_single              = function (a) {
    var b = a.getFieldValue("OP");
    if ("NEG" == b) 
        return a = Blockly
            .C
            .valueToCode(a, "NUM", Blockly.C.ORDER_UNARY_NEGATION) || "0",
        "-" == a[0] && (a = " " + a),
        [
            "-" + a,
            Blockly.C.ORDER_UNARY_NEGATION
        ];
    a = "SIN" == b || "COS" == b || "TAN" == b
        ? Blockly
            .C
            .valueToCode(a, "NUM", Blockly.C.ORDER_DIVISION) || "0"
        : Blockly
            .C
            .valueToCode(a, "NUM", Blockly.C.ORDER_NONE) || "0";
    switch (b) {
        case "ABS":
            var c = "Math.abs(" + a + ")";
            break;
        case "ROOT":
            c = "Math.sqrt(" + a + ")";
            break;
        case "LN":
            c = "Math.log(" + a + ")";
            break;
        case "EXP":
            c = "Math.exp(" + a + ")";
            break;
        case "POW10":
            c = "Math.pow(10," + a + ")";
            break;
        case "ROUND":
            c = "Math.round(" + a + ")";
            break;
        case "ROUNDUP":
            c = "Math.ceil(" + a + ")";
            break;
        case "ROUNDDOWN":
            c = "Math.floor(" + a + ")";
            break;
        case "SIN":
            c = "Math.sin(" + a + " / 180 * Math.PI)";
            break;
        case "COS":
            c = "Math.cos(" + a + " / 180 * Math.PI)";
            break;
        case "TAN":
            c = "Math.tan(" + a + " / 180 * Math.PI)"
    }
    if (c) 
        return [c, Blockly.C.ORDER_FUNCTION_CALL];
    switch (b) {
        case "LOG10":
            c = "Math.log(" + a + ") / Math.log(10)";
            break;
        case "ASIN":
            c = "Math.asin(" + a + ") / Math.PI * 180";
            break;
        case "ACOS":
            c = "Math.acos(" + a + ") / Math.PI * 180";
            break;
        case "ATAN":
            c = "Math.atan(" + a + ") / Math.PI * 180";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    return [c, Blockly.C.ORDER_DIVISION]
};
Blockly.C.math_constant            = function (a) {
    return {
        E           : [
            "Math.E", Blockly.C.ORDER_MEMBER
        ],
        GOLDEN_RATIO: [
            "(1 + Math.sqrt(5)) / 2", Blockly.C.ORDER_DIVISION
        ],
        INFINITY    : [
            "Infinity", Blockly.C.ORDER_ATOMIC
        ],
        PI          : [
            "Math.PI", Blockly.C.ORDER_MEMBER
        ],
        SQRT1_2     : [
            "Math.SQRT1_2", Blockly.C.ORDER_MEMBER
        ],
        SQRT2       : ["Math.SQRT2", Blockly.C.ORDER_MEMBER]
    }[a.getFieldValue("CONSTANT")]
};
Blockly.C.math_number_property     = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "NUMBER_TO_CHECK", Blockly.C.ORDER_MODULUS) || "0",
        c = a.getFieldValue("PROPERTY");
    if ("PRIME" == c) 
        return [
            Blockly
                .C
                .provideFunction_("mathIsPrime", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(n) {",
                    "  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods",
                    "  if (n == 2 || n == 3) {",
                    "    return true;",
                    "  }",
                    "  // False if n is NaN, negative, is 1, or not whole.",
                    "  // And false if n is divisible by 2 or 3.",
                    "  if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {",
                    "    return false;",
                    "  }",
                    "  // Check all the numbers of form 6k +/- 1, up to sqrt(n).",
                    "  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {",
                    "    if (n % (x - 1) == 0 || n % (x + 1) == 0) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "  return true;",
                    "}"
                ]) + "(" + b + ")",
            Blockly.C.ORDER_FUNCTION_CALL
        ];
    switch (c) {
        case "EVEN":
            var d = b + " % 2 == 0";
            break;
        case "ODD":
            d = b + " % 2 == 1";
            break;
        case "WHOLE":
            d = b + " % 1 == 0";
            break;
        case "POSITIVE":
            d = b + " > 0";
            break;
        case "NEGATIVE":
            d = b + " < 0";
            break;
        case "DIVISIBLE_BY":
            a = Blockly
                .C
                .valueToCode(a, "DIVISOR", Blockly.C.ORDER_MODULUS) || "0",
            d = b + " % " + a + " == 0"
    }
    return [d, Blockly.C.ORDER_EQUALITY]
};
Blockly.C.math_change              = function (a) {
    var b = Blockly
        .C
        .valueToCode(a, "DELTA", Blockly.C.ORDER_ADDITION) || "0";
    a = Blockly
        .C
        .variableDB_
        .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    return a + " = (typeof " + a + " == 'number' ? " + a + " : 0) + " + b + ";\n"
};
Blockly.C.math_round               = Blockly.C.math_single;
Blockly.C.math_trig                = Blockly.C.math_single;
Blockly.C.math_on_list             = function (a) {
    var b = a.getFieldValue("OP");
    switch (b) {
        case "SUM":
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_MEMBER) || "[]";
            a += ".reduce(function(x, y) {return x + y;})";
            break;
        case "MIN":
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_COMMA) || "[]";
            a = "Math.min.apply(null, " + a + ")";
            break;
        case "MAX":
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_COMMA) || "[]";
            a = "Math.max.apply(null, " + a + ")";
            break;
        case "AVERAGE":
            b = Blockly
                .C
                .provideFunction_("mathMean", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {",
                    "  return myList.reduce(function(x, y) {return x + y;}) / myList.length;",
                    "}"
                ]);
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "MEDIAN":
            b = Blockly
                .C
                .provideFunction_("mathMedian", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(myList) {",
                    "  var localList = myList.filter(function (x) {return typeof x == 'number';});",
                    "  if (!localList.length) return null;",
                    "  localList.sort(function(a, b) {return b - a;});",
                    "  if (localList.length % 2 == 0) {",
                    "    return (localList[localList.length / 2 - 1] + localList[localList.length /" +
                            " 2]) / 2;",
                    "  } else {",
                    "    return localList[(localList.length - 1) / 2];",
                    "  }",
                    "}"
                ]);
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "MODE":
            b = Blockly
                .C
                .provideFunction_("mathModes", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(values) {",
                    "  var modes = [];",
                    "  var counts = [];",
                    "  var maxCount = 0;",
                    "  for (var i = 0; i < values.length; i++) {",
                    "    var value = values[i];",
                    "    var found = false;",
                    "    var thisCount;",
                    "    for (var j = 0; j < counts.length; j++) {",
                    "      if (counts[j][0] === value) {",
                    "        thisCount = ++counts[j][1];",
                    "        found = true;",
                    "        break;",
                    "      }",
                    "    }",
                    "    if (!found) {",
                    "      counts.push([value, 1]);",
                    "      thisCount = 1;",
                    "    }",
                    "    maxCount = Math.max(thisCount, maxCount);",
                    "  }",
                    "  for (var j = 0; j < counts.length; j++) {",
                    "    if (counts[j][1] == maxCount) {",
                    "        modes.push(counts[j][0]);",
                    "    }",
                    "  }",
                    "  return modes;",
                    "}"
                ]);
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "STD_DEV":
            b = Blockly
                .C
                .provideFunction_("mathStandardDeviation", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(numbers) {",
                    "  var n = numbers.length;",
                    "  if (!n) return null;",
                    "  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;",
                    "  var variance = 0;",
                    "  for (var j = 0; j < n; j++) {",
                    "    variance += Math.pow(numbers[j] - mean, 2);",
                    "  }",
                    "  variance = variance / n;",
                    "  return Math.sqrt(variance);",
                    "}"
                ]);
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        case "RANDOM":
            b = Blockly
                .C
                .provideFunction_("mathRandomList", [
                    "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(list) {",
                    "  var x = Math.floor(Math.random() * list.length);",
                    "  return list[x];",
                    "}"
                ]);
            a = Blockly
                .C
                .valueToCode(a, "LIST", Blockly.C.ORDER_NONE) || "[]";
            a = b + "(" + a + ")";
            break;
        default:
            throw "Unknown operator: " + b;
    }
    return [a, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.math_modulo              = function (a) {
    var b = Blockly
        .C
        .valueToCode(a, "DIVIDEND", Blockly.C.ORDER_MODULUS) || "0";
    a = Blockly
        .C
        .valueToCode(a, "DIVISOR", Blockly.C.ORDER_MODULUS) || "0";
    return [
        b + " % " + a,
        Blockly.C.ORDER_MODULUS
    ]
};
Blockly.C.math_constrain           = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "VALUE", Blockly.C.ORDER_COMMA) || "0",
        c = Blockly
            .C
            .valueToCode(a, "LOW", Blockly.C.ORDER_COMMA) || "0";
    a = Blockly
        .C
        .valueToCode(a, "HIGH", Blockly.C.ORDER_COMMA) || "Infinity";
    return [
        "Math.min(Math.max(" + b + ", " + c + "), " + a + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.math_random_int          = function (a) {
    var b = Blockly
        .C
        .valueToCode(a, "FROM", Blockly.C.ORDER_COMMA) || "0";
    a = Blockly
        .C
        .valueToCode(a, "TO", Blockly.C.ORDER_COMMA) || "0";
    return [
        Blockly
            .C
            .provideFunction_("mathRandomInt", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(a, b) {",
                "  if (a > b) {",
                "    // Swap a and b to ensure a is smaller.",
                "    var c = a;",
                "    a = b;",
                "    b = c;",
                "  }",
                "  return Math.floor(Math.random() * (b - a + 1) + a);",
                "}"
            ]) + "(" + b + ", " + a + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.math_random_float        = function (a) {
    return ["Math.random()", Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.variables                = {};
Blockly.C.variables_get            = function (a) {
    return [
        Blockly
            .C
            .variableDB_
            .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.variables_set            = function (a) {
    var b = Blockly
        .C
        .valueToCode(a, "VALUE", Blockly.C.ORDER_ASSIGNMENT) || "0";
    return Blockly
        .C
        .variableDB_
        .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE) + " = " + b +
                ";\n"
};
Blockly.C.colour                   = {};
Blockly.C.colour_picker            = function (a) {
    return [
        "'" + a.getFieldValue("COLOUR") + "'",
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.colour_random            = function (a) {
    return [
        Blockly
            .C
            .provideFunction_("colourRandom", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "() {",
                "  var num = Math.floor(Math.random() * Math.pow(2, 24));",
                "  return '#' + ('00000' + num.toString(16)).substr(-6);",
                "}"
            ]) + "()",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.colour_rgb               = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "RED", Blockly.C.ORDER_COMMA) || 0,
        c = Blockly
            .C
            .valueToCode(a, "GREEN", Blockly.C.ORDER_COMMA) || 0;
    a = Blockly
        .C
        .valueToCode(a, "BLUE", Blockly.C.ORDER_COMMA) || 0;
    return [
        Blockly
            .C
            .provideFunction_("colourRgb", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b) {",
                "  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;",
                "  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;",
                "  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;",
                "  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);",
                "  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);",
                "  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);",
                "  return '#' + r + g + b;",
                "}"
            ]) + "(" + b + ", " + c + ", " + a + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.colour_blend             = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "COLOUR1", Blockly.C.ORDER_COMMA) || "'#000000'",
        c = Blockly
            .C
            .valueToCode(a, "COLOUR2", Blockly.C.ORDER_COMMA) || "'#000000'";
    a = Blockly
        .C
        .valueToCode(a, "RATIO", Blockly.C.ORDER_COMMA) || .5;
    return [
        Blockly
            .C
            .provideFunction_("colourBlend", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(c1, c2, ratio) {",
                "  ratio = Math.max(Math.min(Number(ratio), 1), 0);",
                "  var r1 = parseInt(c1.substring(1, 3), 16);",
                "  var g1 = parseInt(c1.substring(3, 5), 16);",
                "  var b1 = parseInt(c1.substring(5, 7), 16);",
                "  var r2 = parseInt(c2.substring(1, 3), 16);",
                "  var g2 = parseInt(c2.substring(3, 5), 16);",
                "  var b2 = parseInt(c2.substring(5, 7), 16);",
                "  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);",
                "  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);",
                "  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);",
                "  r = ('0' + (r || 0).toString(16)).slice(-2);",
                "  g = ('0' + (g || 0).toString(16)).slice(-2);",
                "  b = ('0' + (b || 0).toString(16)).slice(-2);",
                "  return '#' + r + g + b;",
                "}"
            ]) + "(" + b + ", " + c + ", " + a + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.procedures               = {};
Blockly.C.procedures_defreturn     = function (a) {
    var b = Blockly
            .C
            .variableDB_
            .getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c = Blockly
            .C
            .statementToCode(a, "STACK");
    Blockly.C.STATEMENT_PREFIX && (
        c = Blockly.C.prefixLines(Blockly.C.STATEMENT_PREFIX.replace(/%1/g, "'" + a.id + "'"), Blockly.C.INDENT) +
            c
    );
    Blockly.C.INFINITE_LOOP_TRAP && (
        c = Blockly.C.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + a.id + "'") + c
    );
    var d = Blockly
        .C
        .valueToCode(a, "RETURN", Blockly.C.ORDER_NONE) || "";
    d && (d = "  return " + d + ";\n");
    for (var e = [], f = 0; f < a.arguments_.length; f++) 
        e[f] = Blockly
            .C
            .variableDB_
            .getName(a.arguments_[f], Blockly.Variables.NAME_TYPE);
    c                          = "function " + b + "(" + e.join(", ") + ") {\n" + c + d + "}";
    c                          = Blockly
        .C
        .scrub_(a, c);
    Blockly
        .C
        .definitions_["%" + b] = c;
    return null
};
Blockly.C.procedures_defnoreturn   = Blockly.C.procedures_defreturn;
Blockly.C.procedures_callreturn    = function (a) {
    for (
        var b = Blockly.C.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c     = [],
        d     = 0;
        d < a.arguments_.length;
        d++
    ) 
        c[d] = Blockly
            .C
            .valueToCode(a, "ARG" + d, Blockly.C.ORDER_COMMA) || "null";
    return [
        b + "(" + c.join(", ") + ")",
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.procedures_callnoreturn  = function (a) {
    for (
        var b = Blockly.C.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c     = [],
        d     = 0;
        d < a.arguments_.length;
        d++
    ) 
        c[d] = Blockly
            .C
            .valueToCode(a, "ARG" + d, Blockly.C.ORDER_COMMA) || "null";
    return b + "(" + c.join(", ") + ");\n"
};
Blockly.C.procedures_ifreturn      = function (a) {
    var b = "if (" + (
        Blockly.C.valueToCode(a, "CONDITION", Blockly.C.ORDER_NONE) || "false"
    ) + ") {\n";
    a.hasReturnValue_
        ? (
            a = Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_NONE) || "null",
            b += "  return " + a + ";\n"
        )
        : b += "  return;\n";
    return b + "}\n"
};
Blockly.C.texts                    = {};
Blockly.C.text                     = function (a) {
    return [
        Blockly
            .C
            .quote_(a.getFieldValue("TEXT")),
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.text_join                = function (a) {
    switch (a.itemCount_) {
        case 0:
            return ["''", Blockly.C.ORDER_ATOMIC];
        case 1:
            return [
                "String(" + (
                    Blockly.C.valueToCode(a, "ADD0", Blockly.C.ORDER_NONE) || "''"
                ) + ")",
                Blockly.C.ORDER_FUNCTION_CALL
            ];
        case 2:
            var b = Blockly
                .C
                .valueToCode(a, "ADD0", Blockly.C.ORDER_NONE) || "''";
            a = Blockly
                .C
                .valueToCode(a, "ADD1", Blockly.C.ORDER_NONE) || "''";
            return [
                "String(" + b + ") + String(" + a + ")",
                Blockly.C.ORDER_ADDITION
            ];
        default:
            for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) 
                b[c] = Blockly
                    .C
                    .valueToCode(a, "ADD" + c, Blockly.C.ORDER_COMMA) || "''";
            a = "[" + b.join(",") + "].join('')";
            return [a, Blockly.C.ORDER_FUNCTION_CALL]
    }
};
Blockly.C.text_append              = function (a) {
    var b = Blockly
        .C
        .variableDB_
        .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly
        .C
        .valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''";
    return b + " = String(" + b + ") + String(" + a + ");\n"
};
Blockly.C.text_length              = function (a) {
    return [
        (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_FUNCTION_CALL) || "''") + "." +
                "length",
        Blockly.C.ORDER_MEMBER
    ]
};
Blockly.C.text_isEmpty             = function (a) {
    return [
        "!" + (
            Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "''"
        ) + ".length",
        Blockly.C.ORDER_LOGICAL_NOT
    ]
};
Blockly.C.text_indexOf             = function (a) {
    var b = "FIRST" == a.getFieldValue("END")
            ? "indexOf"
            : "lastIndexOf",
        c = Blockly
            .C
            .valueToCode(a, "FIND", Blockly.C.ORDER_NONE) || "''",
        b = (Blockly.C.valueToCode(a, "VALUE", Blockly.C.ORDER_MEMBER) || "''") + "." +
                b + "(" + c + ")";
    return a.workspace.options.oneBasedIndex
        ? [
            b + " + 1",
            Blockly.C.ORDER_ADDITION
        ]
        : [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_charAt              = function (a) {
    var b = a.getFieldValue("WHERE") || "FROM_START",
        c = Blockly
            .C
            .valueToCode(
                a,
                "VALUE",
                "RANDOM" == b
                    ? Blockly.C.ORDER_NONE
                    : Blockly.C.ORDER_MEMBER
            ) || "''";
    switch (b) {
        case "FIRST":
            return [
                c + ".charAt(0)",
                Blockly.C.ORDER_FUNCTION_CALL
            ];
        case "LAST":
            return [
                c + ".slice(-1)",
                Blockly.C.ORDER_FUNCTION_CALL
            ];
        case "FROM_START":
            return a = Blockly
                .C
                .getAdjusted(a, "AT"),
            [
                c + ".charAt(" + a + ")",
                Blockly.C.ORDER_FUNCTION_CALL
            ];
        case "FROM_END":
            return a = Blockly
                .C
                .getAdjusted(a, "AT", 1, !0),
            [
                c + ".slice(" + a + ").charAt(0)",
                Blockly.C.ORDER_FUNCTION_CALL
            ];
        case "RANDOM":
            return [
                Blockly
                    .C
                    .provideFunction_("textRandomLetter", [
                        "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(text) {",
                        "  var x = Math.floor(Math.random() * text.length);",
                        "  return text[x];",
                        "}"
                    ]) + "(" + c + ")",
                Blockly.C.ORDER_FUNCTION_CALL
            ]
    }
    throw "Unhandled option (text_charAt).";
};
Blockly.C.text.getIndex_           = function (a, b, c) {
    return "FIRST" == b
        ? "0"
        : "FROM_END" == b
            ? a + ".length - 1 - " + c
            : "LAST" == b
                ? a + ".length - 1"
                : c
};
Blockly.C.text_getSubstring        = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "STRING", Blockly.C.ORDER_FUNCTION_CALL) || "''",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2");
    if ("FIRST" == c && "LAST" == d) 
        var e = b;
    else if (b.match(/^'?\w+'?$/) || "FROM_END" != c && "LAST" != c && "FROM_END" != d && "LAST" != d) {
        switch (c) {
            case "FROM_START":
                e = Blockly
                    .C
                    .getAdjusted(a, "AT1");
                break;
            case "FROM_END":
                e = Blockly
                    .C
                    .getAdjusted(a, "AT1", 1, !1, Blockly.C.ORDER_SUBTRACTION);
                e = b + ".length - " + e;
                break;
            case "FIRST":
                e = "0";
                break;
            default:
                throw "Unhandled option (text_getSubstring).";
        }
        switch (d) {
            case "FROM_START":
                a = Blockly
                    .C
                    .getAdjusted(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly
                    .C
                    .getAdjusted(a, "AT2", 0, !1, Blockly.C.ORDER_SUBTRACTION);
                a = b + ".length - " + a;
                break;
            case "LAST":
                a = b + ".length";
                break;
            default:
                throw "Unhandled option (text_getSubstring).";
        }
        e = b + ".slice(" + e + ", " + a + ")"
    } else {
        e = Blockly
            .C
            .getAdjusted(a, "AT1");
        a = Blockly
            .C
            .getAdjusted(a, "AT2");
        var f = Blockly.C.text.getIndex_;
        var g = {
            FIRST     : "First",
            FROM_END  : "FromEnd",
            FROM_START: "FromStart",
            LAST      : "Last"
        };
        f = Blockly
            .C
            .provideFunction_("subsequence" + g[c] + g[d], [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(sequence" + (
                    "FROM_END" == c || "FROM_START" == c
                        ? ", at1"
                        : ""
                ) + (
                    "FROM_END" == d || "FROM_START" == d
                        ? ", at2"
                        : ""
                ) + ") {",
                "  var start = " + f("sequence", c, "at1") + ";",
                "  var end = " + f("sequence", d, "at2") + " + 1;",
                "  return sequence.slice(start, end);",
                "}"
            ]);
        e = f + "(" + b + (
            "FROM_END" == c || "FROM_START" == c
                ? ", " + e
                : ""
        ) + (
            "FROM_END" == d || "FROM_START" == d
                ? ", " + a
                : ""
        ) + ")"
    }
    return [e, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_changeCase          = function (a) {
    var b = {
        LOWERCASE: ".toLowerCase()",
        TITLECASE: null,
        UPPERCASE: ".toUpperCase()"
    }[a.getFieldValue("CASE")];
    a       = Blockly
        .C
        .valueToCode(
            a,
            "TEXT",
            b
                ? Blockly.C.ORDER_MEMBER
                : Blockly.C.ORDER_NONE
        ) || "''";
    b
        ? b = a + b
        : (
            b = Blockly.C.provideFunction_("textToTitleCase", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(str) {",
                "  return str.replace(/\\S+/g,",
                "      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCas" +
                        "e();});",
                "}"
            ]),
            b = b + "(" + a + ")"
        );
    return [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_trim                = function (a) {
    var b = {
        BOTH : ".trim()",
        LEFT : ".replace(/^[\\s\\xa0]+/, '')",
        RIGHT: ".replace(/[\\s\\xa0]+$/, '')"
    }[a.getFieldValue("MODE")];
    return [
        (Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''") + b,
        Blockly.C.ORDER_FUNCTION_CALL
    ]
};
Blockly.C.text_print               = function (a) {
    return "window.alert(" + (
        Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''"
    ) + ");\n"
};
Blockly.C.text_prompt_ext          = function (a) {
    var b = "window.prompt(" + (
        a.getField("TEXT")
            ? Blockly.C.quote_(a.getFieldValue("TEXT"))
            : Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_NONE) || "''"
    ) + ")";
    "NUMBER" == a.getFieldValue("TYPE") && (b = "parseFloat(" + b + ")");
    return [b, Blockly.C.ORDER_FUNCTION_CALL]
};
Blockly.C.text_prompt              = Blockly.C.text_prompt_ext;
Blockly.C.text_count               = function (a) {
    var b = Blockly
        .C
        .valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''";
    a = Blockly
        .C
        .valueToCode(a, "SUB", Blockly.C.ORDER_NONE) || "''";
    return [
        Blockly
            .C
            .provideFunction_("textCount", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle) {",
                "  if (needle.length === 0) {",
                "    return haystack.length + 1;",
                "  } else {",
                "    return haystack.split(needle).length - 1;",
                "  }",
                "}"
            ]) + "(" + b + ", " + a + ")",
        Blockly.C.ORDER_SUBTRACTION
    ]
};
Blockly.C.text_replace             = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''",
        c = Blockly
            .C
            .valueToCode(a, "FROM", Blockly.C.ORDER_NONE) || "''";
    a = Blockly
        .C
        .valueToCode(a, "TO", Blockly.C.ORDER_NONE) || "''";
    return [
        Blockly
            .C
            .provideFunction_("textReplace", [
                "function " + Blockly.C.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle, replac" +
                        "ement) {",
                '  needle = needle.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,"\\\\$1")',
                '                 .replace(/\\x08/g,"\\\\x08");',
                "  return haystack.replace(new RegExp(needle, 'g'), replacement);",
                "}"
            ]) + "(" + b + ", " + c + ", " + a + ")",
        Blockly.C.ORDER_MEMBER
    ]
};
Blockly.C.text_reverse             = function (a) {
    return [
        (Blockly.C.valueToCode(a, "TEXT", Blockly.C.ORDER_MEMBER) || "''") + ".split(''" +
                ").reverse().join('')",
        Blockly.C.ORDER_MEMBER
    ]
};
Blockly.C.loops                    = {};
Blockly.C.controls_repeat_ext      = function (a) {
    var b = a.getField("TIMES")
        ? String(Number(a.getFieldValue("TIMES")))
        : Blockly
            .C
            .valueToCode(a, "TIMES", Blockly.C.ORDER_ASSIGNMENT) || "0";
    var c = Blockly
            .C
            .statementToCode(a, "DO"),
        c = Blockly
            .C
            .addLoopTrap(c, a.id),
        d = "",
        e = Blockly
            .C
            .variableDB_
            .getDistinctName("count", Blockly.Variables.NAME_TYPE);
    a = b;
    b.match(/^\w+$/) || Blockly.isNumber(b) || (
        a = Blockly.C.variableDB_.getDistinctName("repeat_end", Blockly.Variables.NAME_TYPE),
        d += "var " + a + " = " + b + ";\n"
    );
    return d + (
        "for (var " + e + " = 0; " + e + " < " + a + "; " + e + "++) {\n" + c + "}\n"
    )
};
Blockly.C.controls_repeat          = Blockly.C.controls_repeat_ext;
Blockly.C.controls_whileUntil      = function (a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly
            .C
            .valueToCode(
                a,
                "BOOL",
                b
                    ? Blockly.C.ORDER_LOGICAL_NOT
                    : Blockly.C.ORDER_NONE
            ) || "false",
        d = Blockly
            .C
            .statementToCode(a, "DO"),
        d = Blockly
            .C
            .addLoopTrap(d, a.id);
    b && (c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n"
};
Blockly.C.controls_for             = function (a) {
    var b = Blockly
        .C
        .variableDB_
        .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    var c = Blockly
        .C
        .valueToCode(a, "FROM", Blockly.C.ORDER_ASSIGNMENT) || "0";
    var d = Blockly
            .C
            .valueToCode(a, "TO", Blockly.C.ORDER_ASSIGNMENT) || "0",
        e = Blockly
            .C
            .valueToCode(a, "BY", Blockly.C.ORDER_ASSIGNMENT) || "1",
        f = Blockly
            .C
            .statementToCode(a, "DO"),
        f = Blockly
            .C
            .addLoopTrap(f, a.id);
    if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e)) {
        var g = parseFloat(c) <= parseFloat(d);
        a = "for (" + b + " = " + c + "; " + b + (
            g
                ? " <= "
                : " >= "
        ) + d + "; " + b;
        b = Math.abs(parseFloat(e));
        a = (
            1 == b
                ? a + (
                    g
                        ? "++"
                        : "--"
                )
                : a + ((
                    g
                        ? " += "
                        : " -= "
                ) + b)
        ) + (") {\n" + f + "}\n")
    } else 
        a = "",
        g = c,
        c.match(/^\w+$/) || Blockly.isNumber(c) || (
            g = Blockly.C.variableDB_.getDistinctName(
                b + "_start",
                Blockly.Variables.NAME_TYPE
            ),
            a += "var " + g + " = " + c + ";\n"
        ),
        c = d,
        d.match(/^\w+$/) || Blockly.isNumber(d) || (
            c = Blockly.C.variableDB_.getDistinctName(
                b + "_end",
                Blockly.Variables.NAME_TYPE
            ),
            a += "var " + c + " = " + d + ";\n"
        ),
        d = Blockly
            .C
            .variableDB_
            .getDistinctName(b + "_inc", Blockly.Variables.NAME_TYPE),
        a += "var " + d + " = ",
        a = Blockly.isNumber(e)
            ? a + (Math.abs(e) + ";\n")
            : a + ("Math.abs(" + e + ");\n"),
        a = a + ("if (" + g + " > " + c + ") {\n") + (
            Blockly.C.INDENT + d + " = -" + d + ";\n"
        ),
        a += "}\n",
        a += "for (" + b + " = " + g + "; " + d + " >= 0 ? " + b + " <= " + c + " : " + b +
                " >= " + c + "; " + b + " += " + d + ") {\n" + f + "}\n";
    return a
};
Blockly.C.controls_forEach         = function (a) {
    var b = Blockly
            .C
            .variableDB_
            .getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        c = Blockly
            .C
            .valueToCode(a, "LIST", Blockly.C.ORDER_ASSIGNMENT) || "[]",
        d = Blockly
            .C
            .statementToCode(a, "DO"),
        d = Blockly
            .C
            .addLoopTrap(d, a.id);
    a = "";
    var e = c;
    c.match(/^\w+$/) || (
        e = Blockly.C.variableDB_.getDistinctName(b + "_list", Blockly.Variables.NAME_TYPE),
        a += "var " + e + " = " + c + ";\n"
    );
    c = Blockly
        .C
        .variableDB_
        .getDistinctName(b + "_index", Blockly.Variables.NAME_TYPE);
    d = Blockly.C.INDENT + b + " = " + e + "[" + c + "];\n" + d;
    return a + ("for (var " + c + " in " + e + ") {\n" + d + "}\n")
};
Blockly.C.controls_flow_statements = function (a) {
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return "break;\n";
        case "CONTINUE":
            return "continue;\n"
    }
    throw "Unknown flow statement.";
};
Blockly.C.logic                    = {};
Blockly.C.controls_if              = function (a) {
    var b = 0,
        c = "";
    do {
        var d = Blockly
            .C
            .valueToCode(a, "IF" + b, Blockly.C.ORDER_NONE) || "false";
        var e = Blockly
            .C
            .statementToCode(a, "DO" + b);
        c += (
            0 < b
                ? " else "
                : ""
        ) + "if (" + d + ") {\n" + e + "}";
        ++b
    } while (a.getInput("IF" + b));
    a.getInput("ELSE") && (
        e = Blockly.C.statementToCode(a, "ELSE"),
        c += " else {\n" + e + "}"
    );
    return c + "\n"
};
Blockly.C.controls_ifelse          = Blockly.C.controls_if;
Blockly.C.logic_compare            = function (a) {
    var b = {
            EQ : "==",
            GT : ">",
            GTE: ">=",
            LT : "<",
            LTE: "<=",
            NEQ: "!="
        }[a.getFieldValue("OP")],
        c = "==" == b || "!=" == b
            ? Blockly.C.ORDER_EQUALITY
            : Blockly.C.ORDER_RELATIONAL,
        d = Blockly
            .C
            .valueToCode(a, "A", c) || "0";
    a = Blockly
        .C
        .valueToCode(a, "B", c) || "0";
    return [
        d + " " + b + " " + a,
        c
    ]
};
Blockly.C.logic_operation          = function (a) {
    var b = "AND" == a.getFieldValue("OP")
            ? "&&"
            : "||",
        c = "&&" == b
            ? Blockly.C.ORDER_LOGICAL_AND
            : Blockly.C.ORDER_LOGICAL_OR,
        d = Blockly
            .C
            .valueToCode(a, "A", c);
    a = Blockly
        .C
        .valueToCode(a, "B", c);
    if (d || a) {
        var e = "&&" == b
            ? "true"
            : "false";
        d || (d = e);
        a || (a = e)
    } else 
        a = d = "false";
    return [
        d + " " + b + " " + a,
        c
    ]
};
Blockly.C.logic_negate             = function (a) {
    var b = Blockly.C.ORDER_LOGICAL_NOT;
    return [
        "!" + (
            Blockly.C.valueToCode(a, "BOOL", b) || "true"
        ),
        b
    ]
};
Blockly.C.logic_boolean            = function (a) {
    return [
        "TRUE" == a.getFieldValue("BOOL")
            ? "true"
            : "false",
        Blockly.C.ORDER_ATOMIC
    ]
};
Blockly.C.logic_null               = function (a) {
    return ["null", Blockly.C.ORDER_ATOMIC]
};
Blockly.C.logic_ternary            = function (a) {
    var b = Blockly
            .C
            .valueToCode(a, "IF", Blockly.C.ORDER_CONDITIONAL) || "false",
        c = Blockly
            .C
            .valueToCode(a, "THEN", Blockly.C.ORDER_CONDITIONAL) || "null";
    a = Blockly
        .C
        .valueToCode(a, "ELSE", Blockly.C.ORDER_CONDITIONAL) || "null";
    return [
        b + " ? " + c + " : " + a,
        Blockly.C.ORDER_CONDITIONAL
    ]
};