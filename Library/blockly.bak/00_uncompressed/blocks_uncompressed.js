/**
2017/11/21 blocks_compressed.js のソースコードを解凍
*/
// Do not edit this file; automatically generated by build.py.
// このファイルを編集しないでください。 build.pyによって自動的に生成されます。
'use strict';

// Copyright 2012 Google Inc.  Apache License 2.0
Blockly.Blocks.lists        = {};
Blockly.Constants           = {};
Blockly.Constants.Lists     = {};
Blockly.Constants.Lists.HUE = 260;
Blockly.Blocks.lists.HUE    = Blockly.Constants.Lists.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        colour  : "%{BKY_LISTS_HUE}",
        helpUrl : "%{BKY_LISTS_CREATE_EMPTY_HELPURL}",
        message0: "%{BKY_LISTS_CREATE_EMPTY_TITLE}",
        output  : "Array",
        tooltip : "%{BKY_LISTS_CREATE_EMPTY_TOOLTIP}",
        type    : "lists_create_empty"
    }, {
        args0   : [
            {
                name: "ITEM",
                type: "input_value"
            }, {
                check: "Number",
                name : "NUM",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_LISTS_HUE}",
        helpUrl : "%{BKY_LISTS_REPEAT_HELPURL}",
        message0: "%{BKY_LISTS_REPEAT_TITLE}",
        output  : "Array",
        tooltip : "%{BKY_LISTS_REPEAT_TOOLTIP}",
        type    : "lists_repeat"
    }, {
        args0       : [
            {
                check: "Array",
                name : "LIST",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_LISTS_HUE}",
        helpUrl     : "%{BKY_LISTS_REVERSE_HELPURL}",
        inputsInline: !0,
        message0    : "%{BKY_LISTS_REVERSE_MESSAGE0}",
        output      : "Array",
        tooltip     : "%{BKY_LISTS_REVERSE_TOOLTIP}",
        type        : "lists_reverse"
    }, {
        args0   : [
            {
                check: [
                    "String", "Array"
                ],
                name : "VALUE",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_LISTS_HUE}",
        helpUrl : "%{BKY_LISTS_ISEMPTY_HELPURL}",
        message0: "%{BKY_LISTS_ISEMPTY_TITLE}",
        output  : "Boolean",
        tooltip : "%{BKY_LISTS_ISEMPTY_TOOLTIP}",
        type    : "lists_isEmpty"
    }, {
        args0   : [
            {
                check: [
                    "String", "Array"
                ],
                name : "VALUE",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_LISTS_HUE}",
        helpUrl : "%{BKY_LISTS_LENGTH_HELPURL}",
        message0: "%{BKY_LISTS_LENGTH_TITLE}",
        output  : "Number",
        tooltip : "%{BKY_LISTS_LENGTH_TOOLTIP}",
        type    : "lists_length"
    }
]);
Blockly.Blocks.lists_create_with           = {
    compose        : function (a) {
        var b = a.getInputTargetBlock("STACK");
        for (a = []; b;) 
            a.push(b.valueConnection_),
            b = b.nextConnection && b
                .nextConnection
                .targetBlock();
        for (b = 0; b < this.itemCount_; b++) {
            var c = this
                .getInput("ADD" + b)
                .connection
                .targetConnection;
            c && -1 == a.indexOf(c) && c.disconnect()
        }
        this.itemCount_ = a.length;
        this.updateShape_();
        for (b = 0; b < this.itemCount_; b++) 
            Blockly
                .Mutator
                .reconnect(a[b], this, "ADD" + b)
        },
    decompose      : function (a) {
        var b = a.newBlock("lists_create_with_container");
        b.initSvg();
        for (var c = b.getInput("STACK").connection, d = 0; d < this.itemCount_; d++) {
            var e = a.newBlock("lists_create_with_item");
            e.initSvg();
            c.connect(e.previousConnection);
            c = e.nextConnection
        }
        return b
    },
    domToMutation  : function (a) {
        this.itemCount_ = parseInt(a.getAttribute("items"), 10);
        this.updateShape_()
    },
    init           : function () {
        this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        this.itemCount_ = 3;
        this.updateShape_();
        this.setOutput(!0, "Array");
        this.setMutator(new Blockly.Mutator(["lists_create_with_item"]));
        this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_TOOLTIP)
    },
    mutationToDom  : function () {
        var a = document.createElement("mutation");
        a.setAttribute("items", this.itemCount_);
        return a
    },
    saveConnections: function (a) {
        a = a.getInputTargetBlock("STACK");
        for (var b = 0; a;) {
            var c = this.getInput("ADD" + b);
            a.valueConnection_ = c && c.connection.targetConnection;
            b++;
            a                  = a.nextConnection && a
                .nextConnection
                .targetBlock()
        }
    },
    updateShape_   : function () {
        this.itemCount_ && this.getInput("EMPTY")
            ? this.removeInput("EMPTY")
            : this.itemCount_ || this.getInput("EMPTY") || this
                .appendDummyInput("EMPTY")
                .appendField(Blockly.Msg.LISTS_CREATE_EMPTY_TITLE);
        for (var a = 0; a < this.itemCount_; a++) 
            if (!this.getInput("ADD" + a)) {
                var b = this.appendValueInput("ADD" + a);
                0 == a && b.appendField(Blockly.Msg.LISTS_CREATE_WITH_INPUT_WITH)
            }
        for (; this.getInput("ADD" + a);) 
            this.removeInput("ADD" + a),
            a++
    }
};
Blockly.Blocks.lists_create_with_container = {
    init: function () {
        this.setColour(Blockly.Blocks.lists.HUE);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD);
        this.appendStatementInput("STACK");
        this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP);
        this.contextMenu = !1
    }
};
Blockly.Blocks.lists_create_with_item      = {
    init: function () {
        this.setColour(Blockly.Blocks.lists.HUE);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TITLE);
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP);
        this.contextMenu = !1
    }
};
Blockly.Blocks.lists_indexOf               = {
    init: function () {
        var a = [
            [
                Blockly.Msg.LISTS_INDEX_OF_FIRST, "FIRST"
            ],
            [
                Blockly.Msg.LISTS_INDEX_OF_LAST, "LAST"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.LISTS_INDEX_OF_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        this.setOutput(!0, "Number");
        this
            .appendValueInput("VALUE")
            .setCheck("Array")
            .appendField(Blockly.Msg.LISTS_INDEX_OF_INPUT_IN_LIST);
        this
            .appendValueInput("FIND")
            .appendField(new Blockly.FieldDropdown(a), "END");
        this.setInputsInline(!0);
        var b = this;
        this.setTooltip(function () {
            return Blockly
                .Msg
                .LISTS_INDEX_OF_TOOLTIP
                .replace(
                    "%1",
                    b.workspace.options.oneBasedIndex
                        ? "0"
                        : "-1"
                )
        })
    }
};
Blockly.Blocks.lists_getIndex              = {
    domToMutation   : function (a) {
        var b = "true" == a.getAttribute("statement");
        this.updateStatement_(b);
        a = "false" != a.getAttribute("at");
        this.updateAt_(a)
    },
    init            : function () {
        var a = [
            [
                Blockly.Msg.LISTS_GET_INDEX_GET, "GET"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_GET_REMOVE, "GET_REMOVE"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_REMOVE, "REMOVE"
            ]
        ];
        this.WHERE_OPTIONS = [
            [
                Blockly.Msg.LISTS_GET_INDEX_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_FIRST, "FIRST"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_LAST, "LAST"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_RANDOM, "RANDOM"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.LISTS_GET_INDEX_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        a = new Blockly.FieldDropdown(a, function (a) {
            this
                .sourceBlock_
                .updateStatement_("REMOVE" == a)
        });
        this
            .appendValueInput("VALUE")
            .setCheck("Array")
            .appendField(Blockly.Msg.LISTS_GET_INDEX_INPUT_IN_LIST);
        this
            .appendDummyInput()
            .appendField(a, "MODE")
            .appendField("", "SPACE");
        this.appendDummyInput("AT");
        Blockly.Msg.LISTS_GET_INDEX_TAIL && this
            .appendDummyInput("TAIL")
            .appendField(Blockly.Msg.LISTS_GET_INDEX_TAIL);
        this.setInputsInline(!0);
        this.setOutput(!0);
        this.updateAt_(!0);
        var b = this;
        this.setTooltip(function () {
            var a = b.getFieldValue("MODE"),
                d = b.getFieldValue("WHERE"),
                e = "";
            switch (a + " " + d) {
                case "GET FROM_START":
                case "GET FROM_END":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM;
                    break;
                case "GET FIRST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST;
                    break;
                case "GET LAST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST;
                    break;
                case "GET RANDOM":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM;
                    break;
                case "GET_REMOVE FROM_START":
                case "GET_REMOVE FROM_END":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM;
                    break;
                case "GET_REMOVE FIRST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST;
                    break;
                case "GET_REMOVE LAST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST;
                    break;
                case "GET_REMOVE RANDOM":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM;
                    break;
                case "REMOVE FROM_START":
                case "REMOVE FROM_END":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM;
                    break;
                case "REMOVE FIRST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST;
                    break;
                case "REMOVE LAST":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST;
                    break;
                case "REMOVE RANDOM":
                    e = Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM
            }
            if ("FROM_START" == d || "FROM_END" == d) 
                e += "  " + (
                    "FROM_START" == d
                        ? Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP
                        : Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP
                ).replace(
                    "%1",
                    b.workspace.options.oneBasedIndex
                        ? "#1"
                        : "#0"
                );
            return e
        })
    },
    mutationToDom   : function () {
        var a = document.createElement("mutation");
        a.setAttribute("statement", !this.outputConnection);
        var b = this
            .getInput("AT")
            .type == Blockly.INPUT_VALUE;
        a.setAttribute("at", b);
        return a
    },
    updateAt_       : function (a) {
        this.removeInput("AT");
        this.removeInput("ORDINAL", !0);
        a
            ? (
                this.appendValueInput("AT").setCheck("Number"),
                Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)
            )
            : this.appendDummyInput("AT");
        var b = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function (b) {
            var c = "FROM_START" == b || "FROM_END" == b;
            if (c != a) {
                var e = this.sourceBlock_;
                e.updateAt_(c);
                e.setFieldValue(b, "WHERE");
                return null
            }
        });
        this
            .getInput("AT")
            .appendField(b, "WHERE");
        Blockly.Msg.LISTS_GET_INDEX_TAIL && this.moveInputBefore("TAIL", null)
    },
    updateStatement_: function (a) {
        a != !this.outputConnection && (
            this.unplug(!0, !0),
            a
                ? (
                    this.setOutput(!1),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0)
                )
                : (
                    this.setPreviousStatement(!1),
                    this.setNextStatement(!1),
                    this.setOutput(!0)
                )
        )
    }
};
Blockly.Blocks.lists_setIndex              = {
    domToMutation: function (a) {
        a = "false" != a.getAttribute("at");
        this.updateAt_(a)
    },
    init         : function () {
        var a = [
            [
                Blockly.Msg.LISTS_SET_INDEX_SET, "SET"
            ],
            [
                Blockly.Msg.LISTS_SET_INDEX_INSERT, "INSERT"
            ]
        ];
        this.WHERE_OPTIONS = [
            [
                Blockly.Msg.LISTS_GET_INDEX_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_FIRST, "FIRST"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_LAST, "LAST"
            ],
            [
                Blockly.Msg.LISTS_GET_INDEX_RANDOM, "RANDOM"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.LISTS_SET_INDEX_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        this
            .appendValueInput("LIST")
            .setCheck("Array")
            .appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_IN_LIST);
        this
            .appendDummyInput()
            .appendField(new Blockly.FieldDropdown(a), "MODE")
            .appendField("", "SPACE");
        this.appendDummyInput("AT");
        this
            .appendValueInput("TO")
            .appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_TO);
        this.setInputsInline(!0);
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setTooltip(Blockly.Msg.LISTS_SET_INDEX_TOOLTIP);
        this.updateAt_(!0);
        var b = this;
        this.setTooltip(function () {
            var a = b.getFieldValue("MODE"),
                d = b.getFieldValue("WHERE"),
                e = "";
            switch (a + " " + d) {
                case "SET FROM_START":
                case "SET FROM_END":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM;
                    break;
                case "SET FIRST":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST;
                    break;
                case "SET LAST":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST;
                    break;
                case "SET RANDOM":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM;
                    break;
                case "INSERT FROM_START":
                case "INSERT FROM_END":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM;
                    break;
                case "INSERT FIRST":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST;
                    break;
                case "INSERT LAST":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST;
                    break;
                case "INSERT RANDOM":
                    e = Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM
            }
            if ("FROM_START" == d || "FROM_END" == d) 
                e += "  " + Blockly
                    .Msg
                    .LISTS_INDEX_FROM_START_TOOLTIP
                    .replace(
                        "%1",
                        b.workspace.options.oneBasedIndex
                            ? "#1"
                            : "#0"
                    );
            return e
        })
    },
    mutationToDom: function () {
        var a = document.createElement("mutation"),
            b = this
                .getInput("AT")
                .type == Blockly.INPUT_VALUE;
        a.setAttribute("at", b);
        return a
    },
    updateAt_    : function (a) {
        this.removeInput("AT");
        this.removeInput("ORDINAL", !0);
        a
            ? (
                this.appendValueInput("AT").setCheck("Number"),
                Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)
            )
            : this.appendDummyInput("AT");
        var b = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function (b) {
            var c = "FROM_START" == b || "FROM_END" == b;
            if (c != a) {
                var e = this.sourceBlock_;
                e.updateAt_(c);
                e.setFieldValue(b, "WHERE");
                return null
            }
        });
        this.moveInputBefore("AT", "TO");
        this.getInput("ORDINAL") && this.moveInputBefore("ORDINAL", "TO");
        this
            .getInput("AT")
            .appendField(b, "WHERE")
    }
};
Blockly.Blocks.lists_getSublist            = {
    domToMutation: function (a) {
        var b = "true" == a.getAttribute("at1");
        a = "true" == a.getAttribute("at2");
        this.updateAt_(1, b);
        this.updateAt_(2, a)
    },
    init         : function () {
        this.WHERE_OPTIONS_1 = [
            [
                Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.LISTS_GET_SUBLIST_START_FIRST, "FIRST"
            ]
        ];
        this.WHERE_OPTIONS_2 = [
            [
                Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.LISTS_GET_SUBLIST_END_LAST, "LAST"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.LISTS_GET_SUBLIST_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        this
            .appendValueInput("LIST")
            .setCheck("Array")
            .appendField(Blockly.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST);
        this.appendDummyInput("AT1");
        this.appendDummyInput("AT2");
        Blockly.Msg.LISTS_GET_SUBLIST_TAIL && this
            .appendDummyInput("TAIL")
            .appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);
        this.setInputsInline(!0);
        this.setOutput(!0, "Array");
        this.updateAt_(1, !0);
        this.updateAt_(2, !0);
        this.setTooltip(Blockly.Msg.LISTS_GET_SUBLIST_TOOLTIP)
    },
    mutationToDom: function () {
        var a = document.createElement("mutation"),
            b = this
                .getInput("AT1")
                .type == Blockly.INPUT_VALUE;
        a.setAttribute("at1", b);
        b = this
            .getInput("AT2")
            .type == Blockly.INPUT_VALUE;
        a.setAttribute("at2", b);
        return a
    },
    updateAt_    : function (a, b) {
        this.removeInput("AT" + a);
        this.removeInput("ORDINAL" + a, !0);
        b
            ? (
                this.appendValueInput("AT" + a).setCheck("Number"),
                Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput(
                    "ORDINAL" + a
                ).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)
            )
            : this.appendDummyInput("AT" + a);
        var c = new Blockly.FieldDropdown(this["WHERE_OPTIONS_" + a], function (c) {
            var d = "FROM_START" == c || "FROM_END" == c;
            if (d != b) {
                var f = this.sourceBlock_;
                f.updateAt_(a, d);
                f.setFieldValue(c, "WHERE" + a);
                return null
            }
        });
        this
            .getInput("AT" + a)
            .appendField(c, "WHERE" + a);
        1 == a && (
            this.moveInputBefore("AT1", "AT2"),
            this.getInput("ORDINAL1") && this.moveInputBefore("ORDINAL1", "AT2")
        );
        Blockly.Msg.LISTS_GET_SUBLIST_TAIL && this.moveInputBefore("TAIL", null)
    }
};
Blockly.Blocks.lists_sort                  = {
    init: function () {
        this.jsonInit({
            args0   : [
                {
                    name   : "TYPE",
                    options: [
                        [
                            Blockly.Msg.LISTS_SORT_TYPE_NUMERIC, "NUMERIC"
                        ],
                        [
                            Blockly.Msg.LISTS_SORT_TYPE_TEXT, "TEXT"
                        ],
                        [
                            Blockly.Msg.LISTS_SORT_TYPE_IGNORECASE, "IGNORE_CASE"
                        ]
                    ],
                    type   : "field_dropdown"
                }, {
                    name   : "DIRECTION",
                    options: [
                        [
                            Blockly.Msg.LISTS_SORT_ORDER_ASCENDING, "1"
                        ],
                        [
                            Blockly.Msg.LISTS_SORT_ORDER_DESCENDING, "-1"
                        ]
                    ],
                    type   : "field_dropdown"
                }, {
                    check: "Array",
                    name : "LIST",
                    type : "input_value"
                }
            ],
            colour  : Blockly.Blocks.lists.HUE,
            helpUrl : Blockly.Msg.LISTS_SORT_HELPURL,
            message0: Blockly.Msg.LISTS_SORT_TITLE,
            output  : "Array",
            tooltip : Blockly.Msg.LISTS_SORT_TOOLTIP
        })
    }
};
Blockly.Blocks.lists_split                 = {
    domToMutation: function (a) {
        this.updateType_(a.getAttribute("mode"))
    },
    init         : function () {
        var a = this,
            b = new Blockly.FieldDropdown([
                [
                    Blockly.Msg.LISTS_SPLIT_LIST_FROM_TEXT, "SPLIT"
                ],
                [
                    Blockly.Msg.LISTS_SPLIT_TEXT_FROM_LIST, "JOIN"
                ]
            ], function (b) {
                a.updateType_(b)
            });
        this.setHelpUrl(Blockly.Msg.LISTS_SPLIT_HELPURL);
        this.setColour(Blockly.Blocks.lists.HUE);
        this
            .appendValueInput("INPUT")
            .setCheck("String")
            .appendField(b, "MODE");
        this
            .appendValueInput("DELIM")
            .setCheck("String")
            .appendField(Blockly.Msg.LISTS_SPLIT_WITH_DELIMITER);
        this.setInputsInline(!0);
        this.setOutput(!0, "Array");
        this.setTooltip(function () {
            var b = a.getFieldValue("MODE");
            if ("SPLIT" == b) 
                return Blockly.Msg.LISTS_SPLIT_TOOLTIP_SPLIT;
            if ("JOIN" == b) 
                return Blockly.Msg.LISTS_SPLIT_TOOLTIP_JOIN;
            throw "Unknown mode: " + b;
        })
    },
    mutationToDom: function () {
        var a = document.createElement("mutation");
        a.setAttribute("mode", this.getFieldValue("MODE"));
        return a
    },
    updateType_  : function (a) {
        "SPLIT" == a
            ? (
                this.outputConnection.setCheck("Array"),
                this.getInput("INPUT").setCheck("String")
            )
            : (
                this.outputConnection.setCheck("String"),
                this.getInput("INPUT").setCheck("Array")
            )
    }
};
Blockly.Blocks.math                        = {};
Blockly.Constants.Math                     = {};
Blockly.Constants.Math.HUE                 = 230;
Blockly.Blocks.math.HUE                    = Blockly.Constants.Math.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0     : [
            {
                name : "NUM",
                type : "field_number",
                value: 0
            }
        ],
        colour    : "%{BKY_MATH_HUE}",
        extensions: ["parent_tooltip_when_inline"],
        helpUrl   : "%{BKY_MATH_NUMBER_HELPURL}",
        message0  : "%1",
        output    : "Number",
        tooltip   : "%{BKY_MATH_NUMBER_TOOLTIP}",
        type      : "math_number"
    }, {
        args0       : [
            {
                check: "Number",
                name : "A",
                type : "input_value"
            }, {
                name   : "OP",
                options: [
                    [
                        "%{BKY_MATH_ADDITION_SYMBOL}", "ADD"
                    ],
                    [
                        "%{BKY_MATH_SUBTRACTION_SYMBOL}", "MINUS"
                    ],
                    [
                        "%{BKY_MATH_MULTIPLICATION_SYMBOL}", "MULTIPLY"
                    ],
                    [
                        "%{BKY_MATH_DIVISION_SYMBOL}", "DIVIDE"
                    ],
                    [
                        "%{BKY_MATH_POWER_SYMBOL}", "POWER"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Number",
                name : "B",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_MATH_HUE}",
        extensions  : ["math_op_tooltip"],
        helpUrl     : "%{BKY_MATH_ARITHMETIC_HELPURL}",
        inputsInline: !0,
        message0    : "%1 %2 %3",
        output      : "Number",
        type        : "math_arithmetic"
    }, {
        args0     : [
            {
                name   : "OP",
                options: [
                    [
                        "%{BKY_MATH_SINGLE_OP_ROOT}", "ROOT"
                    ],
                    [
                        "%{BKY_MATH_SINGLE_OP_ABSOLUTE}", "ABS"
                    ],
                    [
                        "-", "NEG"
                    ],
                    [
                        "ln", "LN"
                    ],
                    [
                        "log10", "LOG10"
                    ],
                    [
                        "e^", "EXP"
                    ],
                    [
                        "10^", "POW10"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Number",
                name : "NUM",
                type : "input_value"
            }
        ],
        colour    : "%{BKY_MATH_HUE}",
        extensions: ["math_op_tooltip"],
        helpUrl   : "%{BKY_MATH_SINGLE_HELPURL}",
        message0  : "%1 %2",
        output    : "Number",
        type      : "math_single"
    }, {
        args0     : [
            {
                name   : "OP",
                options: [
                    [
                        "%{BKY_MATH_TRIG_SIN}", "SIN"
                    ],
                    [
                        "%{BKY_MATH_TRIG_COS}", "COS"
                    ],
                    [
                        "%{BKY_MATH_TRIG_TAN}", "TAN"
                    ],
                    [
                        "%{BKY_MATH_TRIG_ASIN}", "ASIN"
                    ],
                    [
                        "%{BKY_MATH_TRIG_ACOS}", "ACOS"
                    ],
                    [
                        "%{BKY_MATH_TRIG_ATAN}", "ATAN"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Number",
                name : "NUM",
                type : "input_value"
            }
        ],
        colour    : "%{BKY_MATH_HUE}",
        extensions: ["math_op_tooltip"],
        helpUrl   : "%{BKY_MATH_TRIG_HELPURL}",
        message0  : "%1 %2",
        output    : "Number",
        type      : "math_trig"
    }, {
        args0   : [
            {
                name   : "CONSTANT",
                options: [
                    [
                        "\u03c0", "PI"
                    ],
                    [
                        "e", "E"
                    ],
                    [
                        "\u03c6", "GOLDEN_RATIO"
                    ],
                    [
                        "sqrt(2)", "SQRT2"
                    ],
                    [
                        "sqrt(\u00bd)", "SQRT1_2"
                    ],
                    [
                        "\u221e", "INFINITY"
                    ]
                ],
                type   : "field_dropdown"
            }
        ],
        colour  : "%{BKY_MATH_HUE}",
        helpUrl : "%{BKY_MATH_CONSTANT_HELPURL}",
        message0: "%1",
        output  : "Number",
        tooltip : "%{BKY_MATH_CONSTANT_TOOLTIP}",
        type    : "math_constant"
    }, {
        args0       : [
            {
                check: "Number",
                name : "NUMBER_TO_CHECK",
                type : "input_value"
            }, {
                name   : "PROPERTY",
                options: [
                    [
                        "%{BKY_MATH_IS_EVEN}", "EVEN"
                    ],
                    [
                        "%{BKY_MATH_IS_ODD}", "ODD"
                    ],
                    [
                        "%{BKY_MATH_IS_PRIME}", "PRIME"
                    ],
                    [
                        "%{BKY_MATH_IS_WHOLE}", "WHOLE"
                    ],
                    [
                        "%{BKY_MATH_IS_POSITIVE}", "POSITIVE"
                    ],
                    [
                        "%{BKY_MATH_IS_NEGATIVE}", "NEGATIVE"
                    ],
                    [
                        "%{BKY_MATH_IS_DIVISIBLE_BY}", "DIVISIBLE_BY"
                    ]
                ],
                type   : "field_dropdown"
            }
        ],
        colour      : "%{BKY_MATH_HUE}",
        inputsInline: !0,
        message0    : "%1 %2",
        mutator     : "math_is_divisibleby_mutator",
        output      : "Boolean",
        tooltip     : "%{BKY_MATH_IS_TOOLTIP}",
        type        : "math_number_property"
    }, {
        args0            : [
            {
                name    : "VAR",
                type    : "field_variable",
                variable: "%{BKY_MATH_CHANGE_TITLE_ITEM}"
            }, {
                check: "Number",
                name : "DELTA",
                type : "input_value"
            }
        ],
        colour           : "%{BKY_VARIABLES_HUE}",
        extensions       : ["math_change_tooltip"],
        helpUrl          : "%{BKY_MATH_CHANGE_HELPURL}",
        message0         : "%{BKY_MATH_CHANGE_TITLE}",
        nextStatement    : null,
        previousStatement: null,
        type             : "math_change"
    }, {
        args0   : [
            {
                name   : "OP",
                options: [
                    [
                        "%{BKY_MATH_ROUND_OPERATOR_ROUND}", "ROUND"
                    ],
                    [
                        "%{BKY_MATH_ROUND_OPERATOR_ROUNDUP}", "ROUNDUP"
                    ],
                    [
                        "%{BKY_MATH_ROUND_OPERATOR_ROUNDDOWN}", "ROUNDDOWN"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Number",
                name : "NUM",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_MATH_HUE}",
        helpUrl : "%{BKY_MATH_ROUND_HELPURL}",
        message0: "%1 %2",
        output  : "Number",
        tooltip : "%{BKY_MATH_ROUND_TOOLTIP}",
        type    : "math_round"
    }, {
        args0     : [
            {
                name   : "OP",
                options: [
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_SUM}", "SUM"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_MIN}", "MIN"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_MAX}", "MAX"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_AVERAGE}", "AVERAGE"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_MEDIAN}", "MEDIAN"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_MODE}", "MODE"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_STD_DEV}", "STD_DEV"
                    ],
                    [
                        "%{BKY_MATH_ONLIST_OPERATOR_RANDOM}", "RANDOM"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Array",
                name : "LIST",
                type : "input_value"
            }
        ],
        colour    : "%{BKY_MATH_HUE}",
        extensions: ["math_op_tooltip"],
        helpUrl   : "%{BKY_MATH_ONLIST_HELPURL}",
        message0  : "%1 %2",
        mutator   : "math_modes_of_list_mutator",
        output    : "Number",
        type      : "math_on_list"
    }, {
        args0       : [
            {
                check: "Number",
                name : "DIVIDEND",
                type : "input_value"
            }, {
                check: "Number",
                name : "DIVISOR",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_MATH_HUE}",
        helpUrl     : "%{BKY_MATH_MODULO_HELPURL}",
        inputsInline: !0,
        message0    : "%{BKY_MATH_MODULO_TITLE}",
        output      : "Number",
        tooltip     : "%{BKY_MATH_MODULO_TOOLTIP}",
        type        : "math_modulo"
    }, {
        args0       : [
            {
                check: "Number",
                name : "VALUE",
                type : "input_value"
            }, {
                check: "Number",
                name : "LOW",
                type : "input_value"
            }, {
                check: "Number",
                name : "HIGH",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_MATH_HUE}",
        helpUrl     : "%{BKY_MATH_CONSTRAIN_HELPURL}",
        inputsInline: !0,
        message0    : "%{BKY_MATH_CONSTRAIN_TITLE}",
        output      : "Number",
        tooltip     : "%{BKY_MATH_CONSTRAIN_TOOLTIP}",
        type        : "math_constrain"
    }, {
        args0       : [
            {
                check: "Number",
                name : "FROM",
                type : "input_value"
            }, {
                check: "Number",
                name : "TO",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_MATH_HUE}",
        helpUrl     : "%{BKY_MATH_RANDOM_INT_HELPURL}",
        inputsInline: !0,
        message0    : "%{BKY_MATH_RANDOM_INT_TITLE}",
        output      : "Number",
        tooltip     : "%{BKY_MATH_RANDOM_INT_TOOLTIP}",
        type        : "math_random_int"
    }, {
        colour  : "%{BKY_MATH_HUE}",
        helpUrl : "%{BKY_MATH_RANDOM_FLOAT_HELPURL}",
        message0: "%{BKY_MATH_RANDOM_FLOAT_TITLE_RANDOM}",
        output  : "Number",
        tooltip : "%{BKY_MATH_RANDOM_FLOAT_TOOLTIP}",
        type    : "math_random_float"
    }
]);
Blockly.Constants.Math.TOOLTIPS_BY_OP = {
    ABS     : "%{BKY_MATH_SINGLE_TOOLTIP_ABS}",
    ACOS    : "%{BKY_MATH_TRIG_TOOLTIP_ACOS}",
    ADD     : "%{BKY_MATH_ARITHMETIC_TOOLTIP_ADD}",
    ASIN    : "%{BKY_MATH_TRIG_TOOLTIP_ASIN}",
    ATAN    : "%{BKY_MATH_TRIG_TOOLTIP_ATAN}",
    AVERAGE : "%{BKY_MATH_ONLIST_TOOLTIP_AVERAGE}",
    COS     : "%{BKY_MATH_TRIG_TOOLTIP_COS}",
    DIVIDE  : "%{BKY_MATH_ARITHMETIC_TOOLTIP_DIVIDE}",
    EXP     : "%{BKY_MATH_SINGLE_TOOLTIP_EXP}",
    LN      : "%{BKY_MATH_SINGLE_TOOLTIP_LN}",
    LOG10   : "%{BKY_MATH_SINGLE_TOOLTIP_LOG10}",
    MAX     : "%{BKY_MATH_ONLIST_TOOLTIP_MAX}",
    MEDIAN  : "%{BKY_MATH_ONLIST_TOOLTIP_MEDIAN}",
    MIN     : "%{BKY_MATH_ONLIST_TOOLTIP_MIN}",
    MINUS   : "%{BKY_MATH_ARITHMETIC_TOOLTIP_MINUS}",
    MODE    : "%{BKY_MATH_ONLIST_TOOLTIP_MODE}",
    MULTIPLY: "%{BKY_MATH_ARITHMETIC_TOOLTIP_MULTIPLY}",
    NEG     : "%{BKY_MATH_SINGLE_TOOLTIP_NEG}",
    POW10   : "%{BKY_MATH_SINGLE_TOOLTIP_POW10}",
    POWER   : "%{BKY_MATH_ARITHMETIC_TOOLTIP_POWER}",
    RANDOM  : "%{BKY_MATH_ONLIST_TOOLTIP_RANDOM}",
    ROOT    : "%{BKY_MATH_SINGLE_TOOLTIP_ROOT}",
    SIN     : "%{BKY_MATH_TRIG_TOOLTIP_SIN}",
    STD_DEV : "%{BKY_MATH_ONLIST_TOOLTIP_STD_DEV}",
    SUM     : "%{BKY_MATH_ONLIST_TOOLTIP_SUM}",
    TAN     : "%{BKY_MATH_TRIG_TOOLTIP_TAN}"
};
Blockly
    .Extensions
    .register(
        "math_op_tooltip",
        Blockly.Extensions.buildTooltipForDropdown("OP", Blockly.Constants.Math.TOOLTIPS_BY_OP)
    );
Blockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN   = {
    domToMutation: function (a) {
        a = "true" == a.getAttribute("divisor_input");
        this.updateShape_(a)
    },
    mutationToDom: function () {
        var a = document.createElement("mutation"),
            b = "DIVISIBLE_BY" == this.getFieldValue("PROPERTY");
        a.setAttribute("divisor_input", b);
        return a
    },
    updateShape_ : function (a) {
        var b = this.getInput("DIVISOR");
        a
            ? b || this
                .appendValueInput("DIVISOR")
                .setCheck("Number")
            : b && this.removeInput("DIVISOR")
    }
};
Blockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION = function () {
    this
        .getField("PROPERTY")
        .setValidator(function (a) {
            this
                .sourceBlock_
                .updateShape_("DIVISIBLE_BY" == a)
        })
};
Blockly
    .Extensions
    .registerMutator(
        "math_is_divisibleby_mutator",
        Blockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN,
        Blockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION
    );
Blockly.Constants.Math.CHANGE_TOOLTIP_EXTENSION = function () {
    this.setTooltip(function () {
        return Blockly
            .Msg
            .MATH_CHANGE_TOOLTIP
            .replace("%1", this.getFieldValue("VAR"))
    }.bind(this))
};
Blockly
    .Extensions
    .register(
        "math_change_tooltip",
        Blockly.Extensions.buildTooltipWithFieldValue(Blockly.Msg.MATH_CHANGE_TOOLTIP, "VAR")
    );
Blockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN     = {
    domToMutation: function (a) {
        this.updateType_(a.getAttribute("op"))
    },
    mutationToDom: function () {
        var a = document.createElement("mutation");
        a.setAttribute("op", this.getFieldValue("OP"));
        return a
    },
    updateType_  : function (a) {
        "MODE" == a
            ? this
                .outputConnection
                .setCheck("Array")
            : this
                .outputConnection
                .setCheck("Number")
    }
};
Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION = function () {
    this
        .getField("OP")
        .setValidator(function (a) {
            this.updateType_(a)
        }.bind(this))
};
Blockly
    .Extensions
    .registerMutator(
        "math_modes_of_list_mutator",
        Blockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN,
        Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION
    );
Blockly.Blocks.variables        = {};
Blockly.Constants.Variables     = {};
Blockly.Constants.Variables.HUE = 330;
Blockly.Blocks.variables.HUE    = Blockly.Constants.Variables.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0     : [
            {
                name    : "VAR",
                type    : "field_variable",
                variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
            }
        ],
        colour    : "%{BKY_VARIABLES_HUE}",
        extensions: ["contextMenu_variableSetterGetter"],
        helpUrl   : "%{BKY_VARIABLES_GET_HELPURL}",
        message0  : "%1",
        output    : null,
        tooltip   : "%{BKY_VARIABLES_GET_TOOLTIP}",
        type      : "variables_get"
    }, {
        args0            : [
            {
                name    : "VAR",
                type    : "field_variable",
                variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
            }, {
                name: "VALUE",
                type: "input_value"
            }
        ],
        colour           : "%{BKY_VARIABLES_HUE}",
        extensions       : ["contextMenu_variableSetterGetter"],
        helpUrl          : "%{BKY_VARIABLES_SET_HELPURL}",
        message0         : "%{BKY_VARIABLES_SET}",
        nextStatement    : null,
        previousStatement: null,
        tooltip          : "%{BKY_VARIABLES_SET_TOOLTIP}",
        type             : "variables_set"
    }
]);
Blockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN = {
    customContextMenu: function (a) {
        if ("variables_get" == this.type) {
            var b = "variables_set";
            var c = Blockly.Msg.VARIABLES_GET_CREATE_SET
        } else 
            b = "variables_get",
            c = Blockly.Msg.VARIABLES_SET_CREATE_GET;
        var d = {
                enabled: 0 < this
                    .workspace
                    .remainingCapacity()
            },
            e = this.getFieldValue("VAR");
        d.text = c.replace("%1", e);
        c      = goog
            .dom
            .createDom("field", null, e);
        c.setAttribute("name", "VAR");
        c = goog
            .dom
            .createDom("block", null, c);
        c.setAttribute("type", b);
        d.callback = Blockly
            .ContextMenu
            .callbackFactory(this, c);
        a.push(d)
    }
};
Blockly
    .Extensions
    .registerMixin(
        "contextMenu_variableSetterGetter",
        Blockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN
    );
Blockly.Blocks.colour        = {};
Blockly.Constants.Colour     = {};
Blockly.Constants.Colour.HUE = 20;
Blockly.Blocks.colour.HUE    = Blockly.Constants.Colour.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0     : [
            {
                colour: "#ff0000",
                name  : "COLOUR",
                type  : "field_colour"
            }
        ],
        colour    : "%{BKY_COLOUR_HUE}",
        extensions: ["parent_tooltip_when_inline"],
        helpUrl   : "%{BKY_COLOUR_PICKER_HELPURL}",
        message0  : "%1",
        output    : "Colour",
        tooltip   : "%{BKY_COLOUR_PICKER_TOOLTIP}",
        type      : "colour_picker"
    }, {
        colour  : "%{BKY_COLOUR_HUE}",
        helpUrl : "%{BKY_COLOUR_RANDOM_HELPURL}",
        message0: "%{BKY_COLOUR_RANDOM_TITLE}",
        output  : "Colour",
        tooltip : "%{BKY_COLOUR_RANDOM_TOOLTIP}",
        type    : "colour_random"
    }, {
        args0   : [
            {
                align: "RIGHT",
                check: "Number",
                name : "RED",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Number",
                name : "GREEN",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Number",
                name : "BLUE",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_COLOUR_HUE}",
        helpUrl : "%{BKY_COLOUR_RGB_HELPURL}",
        message0: "%{BKY_COLOUR_RGB_TITLE} %{BKY_COLOUR_RGB_RED} %1 %{BKY_COLOUR_RGB_GREEN} %2 %{" +
                "BKY_COLOUR_RGB_BLUE} %3",
        output  : "Colour",
        tooltip : "%{BKY_COLOUR_RGB_TOOLTIP}",
        type    : "colour_rgb"
    }, {
        args0   : [
            {
                align: "RIGHT",
                check: "Colour",
                name : "COLOUR1",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Colour",
                name : "COLOUR2",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Number",
                name : "RATIO",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_COLOUR_HUE}",
        helpUrl : "%{BKY_COLOUR_BLEND_HELPURL}",
        message0: "%{BKY_COLOUR_BLEND_TITLE} %{BKY_COLOUR_BLEND_COLOUR1} %1 %{BKY_COLOUR_BLEND_CO" +
                "LOUR2} %2 %{BKY_COLOUR_BLEND_RATIO} %3",
        output  : "Colour",
        tooltip : "%{BKY_COLOUR_BLEND_TOOLTIP}",
        type    : "colour_blend"
    }
]);
Blockly.Blocks.procedures                  = {};
Blockly.Blocks.procedures.HUE              = 290;
Blockly.Blocks.procedures_defnoreturn      = {
    callType_        : "procedures_callnoreturn",
    compose          : function (a) {
        this.arguments_ = [];
        this.paramIds_  = [];
        for (var b = a.getInputTargetBlock("STACK"); b;) 
            this
                .arguments_
                .push(b.getFieldValue("NAME")),
            this
                .paramIds_
                .push(b.id),
            b = b.nextConnection && b
                .nextConnection
                .targetBlock();
        this.updateParams_();
        Blockly
            .Procedures
            .mutateCallers(this);
        a = a.getFieldValue("STATEMENTS");
        if (null !== a && (a = "TRUE" == a, this.hasStatements_ != a)) 
            if (a) 
                this.setStatements_(!0),
                Blockly
                    .Mutator
                    .reconnect(this.statementConnection_, this, "STACK"),
                this.statementConnection_ = null;
            else {
                a = this
                    .getInput("STACK")
                    .connection;
                if (this.statementConnection_ = a.targetConnection) 
                    a = a.targetBlock(),
                    a.unplug(),
                    a.bumpNeighbours_();
                this.setStatements_(!1)
            }
        },
    customContextMenu: function (a) {
        var b = {
            enabled: !0
        };
        var c = this.getFieldValue("NAME");
        b.text = Blockly
            .Msg
            .PROCEDURES_CREATE_DO
            .replace("%1", c);
        var d = goog
            .dom
            .createDom("mutation");
        d.setAttribute("name", c);
        for (var e = 0; e < this.arguments_.length; e++) 
            c = goog
                .dom
                .createDom("arg"),
            c.setAttribute("name", this.arguments_[e]),
            d.appendChild(c);
        d = goog
            .dom
            .createDom("block", null, d);
        d.setAttribute("type", this.callType_);
        b.callback = Blockly
            .ContextMenu
            .callbackFactory(this, d);
        a.push(b);
        if (!this.isCollapsed()) 
            for (e = 0; e < this.arguments_.length; e++) 
                b = {
                    enabled: !0
                }
            ,
        c      = this.arguments_[e],
        b.text = Blockly
            .Msg
            .VARIABLES_SET_CREATE_GET
            .replace("%1", c),
        d      = goog
            .dom
            .createDom("field", null, c),
        d.setAttribute("name", "VAR"),
        d = goog
            .dom
            .createDom("block", null, d),
        d.setAttribute("type", "variables_get"),
        b.callback = Blockly
            .ContextMenu
            .callbackFactory(this, d),
        a.push(b)
    },
    decompose        : function (a) {
        var b = a.newBlock("procedures_mutatorcontainer");
        b.initSvg();
        this.getInput("RETURN")
            ? b.setFieldValue(
                this.hasStatements_
                    ? "TRUE"
                    : "FALSE",
                "STATEMENTS"
            )
            : b
                .getInput("STATEMENT_INPUT")
                .setVisible(!1);
        for (
            var c = b.getInput("STACK").connection,
            d     = 0;
            d < this.arguments_.length;
            d++
        ) {
            var e = a.newBlock("procedures_mutatorarg");
            e.initSvg();
            e.setFieldValue(this.arguments_[d], "NAME");
            e.oldLocation = d;
            c.connect(e.previousConnection);
            c = e.nextConnection
        }
        Blockly
            .Procedures
            .mutateCallers(this);
        return b
    },
    domToMutation    : function (a) {
        this.arguments_ = [];
        for (var b = 0, c; c = a.childNodes[b]; b++) 
            "arg" == c
                .nodeName
                .toLowerCase() && this
                .arguments_
                .push(c.getAttribute("name"));
        this.updateParams_();
        Blockly
            .Procedures
            .mutateCallers(this);
        this.setStatements_("false" !== a.getAttribute("statements"))
    },
    getProcedureDef  : function () {
        return [
            this.getFieldValue("NAME"), this.arguments_, !1
        ]
    },
    getVars          : function () {
        return this.arguments_
    },
    init             : function () {
        var a = new Blockly.FieldTextInput("", Blockly.Procedures.rename);
        a.setSpellcheck(!1);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_TITLE)
            .appendField(a, "NAME")
            .appendField("", "PARAMS");
        this.setMutator(new Blockly.Mutator(["procedures_mutatorarg"]));

        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setTooltip(Blockly.Msg.PROCEDURES_DEFNORETURN_TOOLTIP);
        this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFNORETURN_HELPURL);
        this.arguments_ = [];
        this.setStatements_(!0);
        this.statementConnection_ = null
    },
    mutationToDom    : function (a) {
        var b = document.createElement("mutation");
        a && b.setAttribute("name", this.getFieldValue("NAME"));
        for (var c = 0; c < this.arguments_.length; c++) {
            var d = document.createElement("arg");
            d.setAttribute("name", this.arguments_[c]);
            a && this.paramIds_ && d.setAttribute("paramId", this.paramIds_[c]);
            b.appendChild(d)
        }
        this.hasStatements_ || b.setAttribute("statements", "false");
        return b
    },
    renameVar        : function (a, b) {
        for (var c = !1, d = 0; d < this.arguments_.length; d++) 
            Blockly
                .Names
                .equals(a, this.arguments_[d]) && (this.arguments_[d] = b, c = !0);
        if (c && (this.updateParams_(), this.mutator.isVisible())) 
            for (var c = this.mutator.workspace_.getAllBlocks(), d = 0, e; e = c[d]; d++) 
                "procedures_mutatorarg" == e.type && Blockly
                    .Names
                    .equals(a, e.getFieldValue("NAME")) && e.setFieldValue(b, "NAME")
        },
    setStatements_   : function (a) {
        this.hasStatements_ !== a && (
            a
                ? (
                    this.appendStatementInput("STACK").appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_DO),
                    this.getInput("RETURN") && this.moveInputBefore("STACK", "RETURN")
                )
                : this.removeInput("STACK", !0),
            this.hasStatements_ = a
        )
    },
    updateParams_    : function () {
        for (var a = !1, b = {}, c = 0; c < this.arguments_.length; c++) {
            if (b[
                "arg_" + this
                    .arguments_[c]
                    .toLowerCase()
            ]) {
                a = !0;
                break
            }
            b[
                "arg_" + this
                    .arguments_[c]
                    .toLowerCase()
            ] = !0
        }
        a
            ? this.setWarningText(Blockly.Msg.PROCEDURES_DEF_DUPLICATE_WARNING)
            : this.setWarningText(null);
        a = "";
        this.arguments_.length && (
            a = Blockly.Msg.PROCEDURES_BEFORE_PARAMS + " " + this.arguments_.join(", ")
        );
        Blockly
            .Events
            .disable();
        try {
            this.setFieldValue(a, "PARAMS")
        } finally {
            Blockly
                .Events
                .enable()
        }
    }
};
Blockly.Blocks.procedures_defreturn        = {
    callType_        : "procedures_callreturn",
    compose          : Blockly.Blocks.procedures_defnoreturn.compose,
    customContextMenu: Blockly.Blocks.procedures_defnoreturn.customContextMenu,
    decompose        : Blockly.Blocks.procedures_defnoreturn.decompose,
    domToMutation    : Blockly.Blocks.procedures_defnoreturn.domToMutation,
    getProcedureDef  : function () {
        return [
            this.getFieldValue("NAME"), this.arguments_, !0
        ]
    },
    getVars          : Blockly.Blocks.procedures_defnoreturn.getVars,
    init             : function () {
        var a = new Blockly.FieldTextInput("", Blockly.Procedures.rename);
        a.setSpellcheck(!1);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_TITLE)
            .appendField(a, "NAME")
            .appendField("", "PARAMS");
        this
            .appendValueInput("RETURN")
            .setAlign(Blockly.ALIGN_RIGHT)
            .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);
        this.setMutator(new Blockly.Mutator(["procedures_mutatorarg"]));
        (
            this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments
        ) && Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT && this.setCommentText(
            Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT
        );
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setTooltip(Blockly.Msg.PROCEDURES_DEFRETURN_TOOLTIP);
        this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFRETURN_HELPURL);
        this.arguments_ = [];
        this.setStatements_(!0);
        this.statementConnection_ = null
    },
    mutationToDom    : Blockly.Blocks.procedures_defnoreturn.mutationToDom,
    renameVar        : Blockly.Blocks.procedures_defnoreturn.renameVar,
    setStatements_   : Blockly.Blocks.procedures_defnoreturn.setStatements_,
    updateParams_    : Blockly.Blocks.procedures_defnoreturn.updateParams_
};
Blockly.Blocks.procedures_mutatorcontainer = {
    init: function () {
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TITLE);
        this.appendStatementInput("STACK");
        this
            .appendDummyInput("STATEMENT_INPUT")
            .appendField(Blockly.Msg.PROCEDURES_ALLOW_STATEMENTS)
            .appendField(new Blockly.FieldCheckbox("TRUE"), "STATEMENTS");
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP);
        this.contextMenu = !1
    }
};
Blockly.Blocks.procedures_mutatorarg       = {
    createNewVar_: function (a) {
        var b = this.sourceBlock_;
        b && b.workspace && b.workspace.options && b.workspace.options.parentWorkspace && b
            .workspace
            .options
            .parentWorkspace
            .createVariable(a)
    },
    init         : function () {
        var a = new Blockly.FieldTextInput("x", this.validator_);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.PROCEDURES_MUTATORARG_TITLE)
            .appendField(a, "NAME");
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORARG_TOOLTIP);
        this.contextMenu   = !1;
        a.onFinishEditing_ = this.createNewVar_;
        a.onFinishEditing_("x")
    },
    validator_   : function (a) {
        return (a = a.replace(/[\s\xa0]+/g, " ").replace(/^ | $/g, "")) || null
    }
};
Blockly.Blocks.procedures_callnoreturn     = {
    customContextMenu      : function (a) {
        var b = {
            enabled: !0
        };
        b.text = Blockly.Msg.PROCEDURES_HIGHLIGHT_DEF;
        var c = this.getProcedureCall(),
            d = this.workspace;
        b.callback = function () {
            var a = Blockly
                .Procedures
                .getDefinition(c, d);
            a && a.select()
        };
        a.push(b)
    },
    defType_               : "procedures_defnoreturn",
    domToMutation          : function (a) {
        var b = a.getAttribute("name");
        this.renameProcedure(this.getProcedureCall(), b);
        for (var b = [], c = [], d = 0, e; e = a.childNodes[d]; d++) 
            "arg" == e
                .nodeName
                .toLowerCase() && (
                    b.push(e.getAttribute("name")),
                    c.push(e.getAttribute("paramId"))
                );
        this.setProcedureParameters_(b, c)
    },
    getProcedureCall       : function () {
        return this.getFieldValue("NAME")
    },
    init                   : function () {
        this
            .appendDummyInput("TOPROW")
            .appendField(this.id, "NAME");
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLNORETURN_HELPURL);
        this.arguments_        = [];
        this.quarkConnections_ = {};
        this.quarkIds_         = null
    },
    mutationToDom          : function () {
        var a = document.createElement("mutation");
        a.setAttribute("name", this.getProcedureCall());
        for (var b = 0; b < this.arguments_.length; b++) {
            var c = document.createElement("arg");
            c.setAttribute("name", this.arguments_[b]);
            a.appendChild(c)
        }
        return a
    },
    onchange               : function (a) {
        if (this.workspace && !this.workspace.isFlyout) 
            if (a.type == Blockly.Events.CREATE && -1 != a.ids.indexOf(this.id)) {
                var b = this.getProcedureCall();
                b = Blockly
                    .Procedures
                    .getDefinition(b, this.workspace);
                !b || b.type == this.defType_ && JSON.stringify(b.arguments_) == JSON.stringify(
                    this.arguments_
                ) || (b = null);
                if (!b) {
                    Blockly
                        .Events
                        .setGroup(a.group);
                    a = goog
                        .dom
                        .createDom("xml");
                    b = goog
                        .dom
                        .createDom("block");
                    b.setAttribute("type", this.defType_);
                    var c = this.getRelativeToSurfaceXY(),
                        d = c.y + 2 * Blockly.SNAP_RADIUS;
                    b.setAttribute("x", c.x + Blockly.SNAP_RADIUS * (
                        this.RTL
                            ? -1
                            : 1
                    ));
                    b.setAttribute("y", d);
                    c = this.mutationToDom();
                    b.appendChild(c);
                    c = goog
                        .dom
                        .createDom("field");
                    c.setAttribute("name", "NAME");
                    c.appendChild(document.createTextNode(this.getProcedureCall()));
                    b.appendChild(c);
                    a.appendChild(b);
                    Blockly
                        .Xml
                        .domToWorkspace(a, this.workspace);
                    Blockly
                        .Events
                        .setGroup(!1)
                }
            } else 
                a.type == Blockly.Events.DELETE && (
                    b = this.getProcedureCall(),
                    b = Blockly.Procedures.getDefinition(b, this.workspace),
                    b || (
                        Blockly.Events.setGroup(a.group),
                        this.dispose(!0, !1),
                        Blockly.Events.setGroup(!1)
                    )
                )
    },
    renameProcedure        : function (a, b) {
        Blockly
            .Names
            .equals(a, this.getProcedureCall()) && (
                this.setFieldValue(b, "NAME"),
                this.setTooltip((
                    this.outputConnection
                        ? Blockly.Msg.PROCEDURES_CALLRETURN_TOOLTIP
                        : Blockly.Msg.PROCEDURES_CALLNORETURN_TOOLTIP
                ).replace("%1", b))
            )
    },
    renameVar              : function (a, b) {
        for (var c = 0; c < this.arguments_.length; c++) 
            Blockly
                .Names
                .equals(a, this.arguments_[c]) && (this.arguments_[c] = b, this.getField(
                "ARGNAME" + c
            ).setValue(b))
    },
    setProcedureParameters_: function (a, b) {
        var c,
            d = Blockly
                .Procedures
                .getDefinition(this.getProcedureCall(), this.workspace);
        var e = d && d.mutator && d
            .mutator
            .isVisible();
        e || (this.quarkConnections_ = {}, this.quarkIds_ = null);
        if (b) 
            if (goog.array.equals(this.arguments_, a)) 
                this.quarkIds_ = b;
            else {
                if (b.length != a.length) 
                    throw "Error: paramNames and paramIds must be the same length.";
                this.setCollapsed(!1);
                this.quarkIds_ || (
                    this.quarkConnections_ = {},
                    a.join("\n") == this.arguments_.join("\n")
                        ? this.quarkIds_   = b
                        : this.quarkIds_   = []
                );
                d             = this.rendered;
                this.rendered = !1;
                for (var f = 0; f < this.arguments_.length; f++) 
                    if (c = this.getInput("ARG" + f)) 
                        c = c.connection.targetConnection,
                        this.quarkConnections_[this.quarkIds_[f]] = c,
                        e && c && -1 == b.indexOf(this.quarkIds_[f]) && (
                            c.disconnect(),
                            c.getSourceBlock().bumpNeighbours_()
                        );
            this.arguments_ = [].concat(a);
                this.updateShape_();
                if (this.quarkIds_ = b) 
                    for (f = 0; f < this.arguments_.length; f++) 
                        e = this.quarkIds_[f],
                        e in this.quarkConnections_ && (
                            c = this.quarkConnections_[e],
                            Blockly.Mutator.reconnect(c, this, "ARG" + f) || delete this.quarkConnections_[e]
                        );
            (this.rendered = d) && this.render()
            }
        },
    updateShape_           : function () {
        for (var a = 0; a < this.arguments_.length; a++) {
            var b = this.getField("ARGNAME" + a);
            if (b) {
                Blockly
                    .Events
                    .disable();
                try {
                    b.setValue(this.arguments_[a])
                } finally {
                    Blockly
                        .Events
                        .enable()
                }
            } else 
                b = new Blockly.FieldLabel(this.arguments_[a]),
                this
                    .appendValueInput("ARG" + a)
                    .setAlign(Blockly.ALIGN_RIGHT)
                    .appendField(b, "ARGNAME" + a)
                    .init()
            }
        for (; this.getInput("ARG" + a);) 
            this.removeInput("ARG" + a),
            a++;
        if (a = this.getInput("TOPROW")) 
            this.arguments_.length
                ? this.getField("WITH") || (
                    a.appendField(Blockly.Msg.PROCEDURES_CALL_BEFORE_PARAMS, "WITH"),
                    a.init()
                )
                : this.getField("WITH") && a.removeField("WITH")
        }
};
Blockly.Blocks.procedures_callreturn       = {
    customContextMenu      : Blockly.Blocks.procedures_callnoreturn.customContextMenu,
    defType_               : "procedures_defreturn",
    domToMutation          : Blockly.Blocks.procedures_callnoreturn.domToMutation,
    getProcedureCall       : Blockly.Blocks.procedures_callnoreturn.getProcedureCall,
    init                   : function () {
        this
            .appendDummyInput("TOPROW")
            .appendField("", "NAME");
        this.setOutput(!0);
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLRETURN_HELPURL);
        this.arguments_        = [];
        this.quarkConnections_ = {};
        this.quarkIds_         = null
    },
    mutationToDom          : Blockly.Blocks.procedures_callnoreturn.mutationToDom,
    onchange               : Blockly.Blocks.procedures_callnoreturn.onchange,
    renameProcedure        : Blockly.Blocks.procedures_callnoreturn.renameProcedure,
    renameVar              : Blockly.Blocks.procedures_callnoreturn.renameVar,
    setProcedureParameters_: Blockly.Blocks.procedures_callnoreturn.setProcedureParameters_,
    updateShape_           : Blockly.Blocks.procedures_callnoreturn.updateShape_
};
Blockly.Blocks.procedures_ifreturn         = {
    domToMutation : function (a) {
        this.hasReturnValue_ = 1 == a.getAttribute("value");
        this.hasReturnValue_ || (
            this.removeInput("VALUE"),
            this.appendDummyInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN)
        )
    },
    FUNCTION_TYPES: [
        "procedures_defnoreturn", "procedures_defreturn"
    ],
    init          : function () {
        this
            .appendValueInput("CONDITION")
            .setCheck("Boolean")
            .appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);
        this
            .appendValueInput("VALUE")
            .appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);
        this.setInputsInline(!0);
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setColour(Blockly.Blocks.procedures.HUE);
        this.setTooltip(Blockly.Msg.PROCEDURES_IFRETURN_TOOLTIP);
        this.setHelpUrl(Blockly.Msg.PROCEDURES_IFRETURN_HELPURL);
        this.hasReturnValue_ = !0
    },
    mutationToDom : function () {
        var a = document.createElement("mutation");
        a.setAttribute("value", Number(this.hasReturnValue_));
        return a
    },
    onchange      : function () {
        if (this.workspace.isDragging && !this.workspace.isDragging()) {
            var a = !1,
                b = this;
            do {
                if (-1 != this.FUNCTION_TYPES.indexOf(b.type)) {
                    a = !0;
                    break
                }
                b = b.getSurroundParent()
            } while (b);
            a
                ? (
                    "procedures_defnoreturn" == b.type && this.hasReturnValue_
                        ? (
                            this.removeInput("VALUE"),
                            this.appendDummyInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN),
                            this.hasReturnValue_ = !1
                        )
                        : "procedures_defreturn" != b.type || this.hasReturnValue_ || (
                            this.removeInput("VALUE"),
                            this.appendValueInput("VALUE").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN),
                            this.hasReturnValue_ = !0
                        ),
                    this.setWarningText(null),
                    this.isInFlyout || this.setDisabled(!1)
                )
                : (
                    this.setWarningText(Blockly.Msg.PROCEDURES_IFRETURN_WARNING),
                    this.isInFlyout || this.getInheritedDisabled() || this.setDisabled(!0)
                )
        }
    }
};
Blockly.Blocks.texts                       = {};
Blockly.Constants.Text                     = {};
Blockly.Constants.Text.HUE                 = 160;
Blockly.Blocks.texts.HUE                   = Blockly.Constants.Text.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0     : [
            {
                name: "TEXT",
                text: "",
                type: "field_input"
            }
        ],
        colour    : "%{BKY_TEXTS_HUE}",
        extensions: [
            "text_quotes", "parent_tooltip_when_inline"
        ],
        helpUrl   : "%{BKY_TEXT_TEXT_HELPURL}",
        message0  : "%1",
        output    : "String",
        tooltip   : "%{BKY_TEXT_TEXT_TOOLTIP}",
        type      : "text"
    }
]);
Blockly.Constants.Text.textQuotesExtension = function () {
    this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
    this.quoteField_("TEXT")
};
Blockly
    .Extensions
    .register("text_quotes", Blockly.Constants.Text.textQuotesExtension);
Blockly.Blocks.text_join                  = {
    compose        : function (a) {
        var b = a.getInputTargetBlock("STACK");
        for (a = []; b;) 
            a.push(b.valueConnection_),
            b = b.nextConnection && b
                .nextConnection
                .targetBlock();
        for (b = 0; b < this.itemCount_; b++) {
            var c = this
                .getInput("ADD" + b)
                .connection
                .targetConnection;
            c && -1 == a.indexOf(c) && c.disconnect()
        }
        this.itemCount_ = a.length;
        this.updateShape_();
        for (b = 0; b < this.itemCount_; b++) 
            Blockly
                .Mutator
                .reconnect(a[b], this, "ADD" + b)
        },
    decompose      : function (a) {
        var b = a.newBlock("text_create_join_container");
        b.initSvg();
        for (var c = b.getInput("STACK").connection, d = 0; d < this.itemCount_; d++) {
            var e = a.newBlock("text_create_join_item");
            e.initSvg();
            c.connect(e.previousConnection);
            c = e.nextConnection
        }
        return b
    },
    domToMutation  : function (a) {
        this.itemCount_ = parseInt(a.getAttribute("items"), 10);
        this.updateShape_()
    },
    init           : function () {
        this.setHelpUrl(Blockly.Msg.TEXT_JOIN_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this.itemCount_ = 2;
        this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
        this.updateShape_();
        this.setOutput(!0, "String");
        this.setMutator(new Blockly.Mutator(["text_create_join_item"]));
        this.setTooltip(Blockly.Msg.TEXT_JOIN_TOOLTIP)
    },
    mutationToDom  : function () {
        var a = document.createElement("mutation");
        a.setAttribute("items", this.itemCount_);
        return a
    },
    saveConnections: function (a) {
        a = a.getInputTargetBlock("STACK");
        for (var b = 0; a;) {
            var c = this.getInput("ADD" + b);
            a.valueConnection_ = c && c.connection.targetConnection;
            b++;
            a                  = a.nextConnection && a
                .nextConnection
                .targetBlock()
        }
    },
    updateShape_   : function () {
        this.itemCount_ && this.getInput("EMPTY")
            ? this.removeInput("EMPTY")
            : this.itemCount_ || this.getInput("EMPTY") || this
                .appendDummyInput("EMPTY")
                .appendField(this.newQuote_(!0))
                .appendField(this.newQuote_(!1));
        for (var a = 0; a < this.itemCount_; a++) 
            if (!this.getInput("ADD" + a)) {
                var b = this.appendValueInput("ADD" + a);
                0 == a && b.appendField(Blockly.Msg.TEXT_JOIN_TITLE_CREATEWITH)
            }
        for (; this.getInput("ADD" + a);) 
            this.removeInput("ADD" + a),
            a++
    }
};
Blockly.Blocks.text_create_join_container = {
    init: function () {
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.TEXT_CREATE_JOIN_TITLE_JOIN);
        this.appendStatementInput("STACK");
        this.setTooltip(Blockly.Msg.TEXT_CREATE_JOIN_TOOLTIP);
        this.contextMenu = !1
    }
};
Blockly.Blocks.text_create_join_item      = {
    init: function () {
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendDummyInput()
            .appendField(Blockly.Msg.TEXT_CREATE_JOIN_ITEM_TITLE_ITEM);
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        this.setTooltip(Blockly.Msg.TEXT_CREATE_JOIN_ITEM_TOOLTIP);
        this.contextMenu = !1
    }
};
Blockly.Blocks.text_append                = {
    init: function () {
        this.setHelpUrl(Blockly.Msg.TEXT_APPEND_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendValueInput("TEXT")
            .appendField(Blockly.Msg.TEXT_APPEND_TO)
            .appendField(
                new Blockly.FieldVariable(Blockly.Msg.TEXT_APPEND_VARIABLE),
                "VAR"
            )
            .appendField(Blockly.Msg.TEXT_APPEND_APPENDTEXT);
        this.setPreviousStatement(!0);
        this.setNextStatement(!0);
        var a = this;
        this.setTooltip(function () {
            return Blockly
                .Msg
                .TEXT_APPEND_TOOLTIP
                .replace("%1", a.getFieldValue("VAR"))
        })
    }
};
Blockly.Blocks.text_length                = {
    init: function () {
        this.jsonInit({
            args0   : [
                {
                    check: [
                        "String", "Array"
                    ],
                    name : "VALUE",
                    type : "input_value"
                }
            ],
            colour  : Blockly.Blocks.texts.HUE,
            helpUrl : Blockly.Msg.TEXT_LENGTH_HELPURL,
            message0: Blockly.Msg.TEXT_LENGTH_TITLE,
            output  : "Number",
            tooltip : Blockly.Msg.TEXT_LENGTH_TOOLTIP
        })
    }
};
Blockly.Blocks.text_isEmpty               = {
    init: function () {
        this.jsonInit({
            args0   : [
                {
                    check: [
                        "String", "Array"
                    ],
                    name : "VALUE",
                    type : "input_value"
                }
            ],
            colour  : Blockly.Blocks.texts.HUE,
            helpUrl : Blockly.Msg.TEXT_ISEMPTY_HELPURL,
            message0: Blockly.Msg.TEXT_ISEMPTY_TITLE,
            output  : "Boolean",
            tooltip : Blockly.Msg.TEXT_ISEMPTY_TOOLTIP
        })
    }
};
Blockly.Blocks.text_indexOf               = {
    init: function () {
        var a = [
            [
                Blockly.Msg.TEXT_INDEXOF_OPERATOR_FIRST, "FIRST"
            ],
            [
                Blockly.Msg.TEXT_INDEXOF_OPERATOR_LAST, "LAST"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_INDEXOF_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this.setOutput(!0, "Number");
        this
            .appendValueInput("VALUE")
            .setCheck("String")
            .appendField(Blockly.Msg.TEXT_INDEXOF_INPUT_INTEXT);
        this
            .appendValueInput("FIND")
            .setCheck("String")
            .appendField(new Blockly.FieldDropdown(a), "END");
        Blockly.Msg.TEXT_INDEXOF_TAIL && this
            .appendDummyInput()
            .appendField(Blockly.Msg.TEXT_INDEXOF_TAIL);
        this.setInputsInline(!0);
        var b = this;
        this.setTooltip(function () {
            return Blockly
                .Msg
                .TEXT_INDEXOF_TOOLTIP
                .replace(
                    "%1",
                    b.workspace.options.oneBasedIndex
                        ? "0"
                        : "-1"
                )
        })
    }
};
Blockly.Blocks.text_charAt                = {
    domToMutation: function (a) {
        a = "false" != a.getAttribute("at");
        this.updateAt_(a)
    },
    init         : function () {
        this.WHERE_OPTIONS = [
            [
                Blockly.Msg.TEXT_CHARAT_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.TEXT_CHARAT_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.TEXT_CHARAT_FIRST, "FIRST"
            ],
            [
                Blockly.Msg.TEXT_CHARAT_LAST, "LAST"
            ],
            [
                Blockly.Msg.TEXT_CHARAT_RANDOM, "RANDOM"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_CHARAT_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this.setOutput(!0, "String");
        this
            .appendValueInput("VALUE")
            .setCheck("String")
            .appendField(Blockly.Msg.TEXT_CHARAT_INPUT_INTEXT);
        this.appendDummyInput("AT");
        this.setInputsInline(!0);
        this.updateAt_(!0);
        var a = this;
        this.setTooltip(function () {
            var b = a.getFieldValue("WHERE"),
                c = Blockly.Msg.TEXT_CHARAT_TOOLTIP;
            if ("FROM_START" == b || "FROM_END" == b) 
                c += "  " + (
                    "FROM_START" == b
                        ? Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP
                        : Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP
                ).replace(
                    "%1",
                    a.workspace.options.oneBasedIndex
                        ? "#1"
                        : "#0"
                );
            return c
        })
    },
    mutationToDom: function () {
        var a = document.createElement("mutation"),
            b = this
                .getInput("AT")
                .type == Blockly.INPUT_VALUE;
        a.setAttribute("at", b);
        return a
    },
    updateAt_    : function (a) {
        this.removeInput("AT");
        this.removeInput("ORDINAL", !0);
        a
            ? (
                this.appendValueInput("AT").setCheck("Number"),
                Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)
            )
            : this.appendDummyInput("AT");
        Blockly.Msg.TEXT_CHARAT_TAIL && (
            this.removeInput("TAIL", !0),
            this.appendDummyInput("TAIL").appendField(Blockly.Msg.TEXT_CHARAT_TAIL)
        );
        var b = new Blockly.FieldDropdown(this.WHERE_OPTIONS, function (b) {
            var c = "FROM_START" == b || "FROM_END" == b;
            if (c != a) {
                var e = this.sourceBlock_;
                e.updateAt_(c);
                e.setFieldValue(b, "WHERE");
                return null
            }
        });
        this
            .getInput("AT")
            .appendField(b, "WHERE")
    }
};
Blockly.Blocks.text_getSubstring          = {
    domToMutation: function (a) {
        var b = "true" == a.getAttribute("at1");
        a = "true" == a.getAttribute("at2");
        this.updateAt_(1, b);
        this.updateAt_(2, a)
    },
    init         : function () {
        this.WHERE_OPTIONS_1 = [
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_START_FIRST, "FIRST"
            ]
        ];
        this.WHERE_OPTIONS_2 = [
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_START, "FROM_START"
            ],
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_END, "FROM_END"
            ],
            [
                Blockly.Msg.TEXT_GET_SUBSTRING_END_LAST, "LAST"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_GET_SUBSTRING_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendValueInput("STRING")
            .setCheck("String")
            .appendField(Blockly.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT);
        this.appendDummyInput("AT1");
        this.appendDummyInput("AT2");
        Blockly.Msg.TEXT_GET_SUBSTRING_TAIL && this
            .appendDummyInput("TAIL")
            .appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL);
        this.setInputsInline(!0);
        this.setOutput(!0, "String");
        this.updateAt_(1, !0);
        this.updateAt_(2, !0);
        this.setTooltip(Blockly.Msg.TEXT_GET_SUBSTRING_TOOLTIP)
    },
    mutationToDom: function () {
        var a = document.createElement("mutation"),
            b = this
                .getInput("AT1")
                .type == Blockly.INPUT_VALUE;
        a.setAttribute("at1", b);
        b = this
            .getInput("AT2")
            .type == Blockly.INPUT_VALUE;
        a.setAttribute("at2", b);
        return a
    },
    updateAt_    : function (a, b) {
        this.removeInput("AT" + a);
        this.removeInput("ORDINAL" + a, !0);
        b
            ? (
                this.appendValueInput("AT" + a).setCheck("Number"),
                Blockly.Msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput(
                    "ORDINAL" + a
                ).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)
            )
            : this.appendDummyInput("AT" + a);
        2 == a && Blockly.Msg.TEXT_GET_SUBSTRING_TAIL && (
            this.removeInput("TAIL", !0),
            this.appendDummyInput("TAIL").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL)
        );
        var c = new Blockly.FieldDropdown(this["WHERE_OPTIONS_" + a], function (c) {
            var d = "FROM_START" == c || "FROM_END" == c;
            if (d != b) {
                var f = this.sourceBlock_;
                f.updateAt_(a, d);
                f.setFieldValue(c, "WHERE" + a);
                return null
            }
        });
        this
            .getInput("AT" + a)
            .appendField(c, "WHERE" + a);
        1 == a && this.moveInputBefore("AT1", "AT2")
    }
};
Blockly.Blocks.text_changeCase            = {
    init: function () {
        var a = [
            [
                Blockly.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE, "UPPERCASE"
            ],
            [
                Blockly.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE, "LOWERCASE"
            ],
            [
                Blockly.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE, "TITLECASE"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_CHANGECASE_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendValueInput("TEXT")
            .setCheck("String")
            .appendField(new Blockly.FieldDropdown(a), "CASE");
        this.setOutput(!0, "String");
        this.setTooltip(Blockly.Msg.TEXT_CHANGECASE_TOOLTIP)
    }
};
Blockly.Blocks.text_trim                  = {
    init: function () {
        var a = [
            [
                Blockly.Msg.TEXT_TRIM_OPERATOR_BOTH, "BOTH"
            ],
            [
                Blockly.Msg.TEXT_TRIM_OPERATOR_LEFT, "LEFT"
            ],
            [
                Blockly.Msg.TEXT_TRIM_OPERATOR_RIGHT, "RIGHT"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_TRIM_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        this
            .appendValueInput("TEXT")
            .setCheck("String")
            .appendField(new Blockly.FieldDropdown(a), "MODE");
        this.setOutput(!0, "String");
        this.setTooltip(Blockly.Msg.TEXT_TRIM_TOOLTIP)
    }
};
Blockly.Blocks.text_print                 = {
    init: function () {
        this.jsonInit({
            args0            : [
                {
                    name: "TEXT",
                    type: "input_value"
                }
            ],
            colour           : Blockly.Blocks.texts.HUE,
            helpUrl          : Blockly.Msg.TEXT_PRINT_HELPURL,
            message0         : Blockly.Msg.TEXT_PRINT_TITLE,
            nextStatement    : null,
            previousStatement: null,
            tooltip          : Blockly.Msg.TEXT_PRINT_TOOLTIP
        })
    }
};
Blockly.Blocks.text_prompt_ext            = {
    domToMutation: function (a) {
        this.updateType_(a.getAttribute("type"))
    },
    init         : function () {
        var a = [
            [
                Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"
            ],
            [
                Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"
            ]
        ];
        this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        var b = this,
            a = new Blockly.FieldDropdown(a, function (a) {
                b.updateType_(a)
            });
        this
            .appendValueInput("TEXT")
            .appendField(a, "TYPE");
        this.setOutput(!0, "String");
        this.setTooltip(function () {
            return "TEXT" == b.getFieldValue("TYPE")
                ? Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT
                : Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER
        })
    },
    mutationToDom: function () {
        var a = document.createElement("mutation");
        a.setAttribute("type", this.getFieldValue("TYPE"));
        return a
    },
    updateType_  : function (a) {
        this
            .outputConnection
            .setCheck(
                "NUMBER" == a
                    ? "Number"
                    : "String"
            )
    }
};
Blockly.Blocks.text_prompt                = {
    domToMutation: Blockly.Blocks.text_prompt_ext.domToMutation,
    init         : function () {
        this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);
        var a = [
                [
                    Blockly.Msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"
                ],
                [
                    Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"
                ]
            ],
            b = this;
        this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);
        this.setColour(Blockly.Blocks.texts.HUE);
        a = new Blockly.FieldDropdown(a, function (a) {
            b.updateType_(a)
        });
        this
            .appendDummyInput()
            .appendField(a, "TYPE")
            .appendField(this.newQuote_(!0))
            .appendField(new Blockly.FieldTextInput(""), "TEXT")
            .appendField(this.newQuote_(!1));
        this.setOutput(!0, "String");
        this.setTooltip(function () {
            return "TEXT" == b.getFieldValue("TYPE")
                ? Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT
                : Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER
        })
    },
    mutationToDom: Blockly.Blocks.text_prompt_ext.mutationToDom,
    updateType_  : Blockly.Blocks.text_prompt_ext.updateType_
};
Blockly.Blocks.text_count                 = {
    init: function () {
        this.jsonInit({
            args0       : [
                {
                    check: "String",
                    name : "SUB",
                    type : "input_value"
                }, {
                    check: "String",
                    name : "TEXT",
                    type : "input_value"
                }
            ],
            colour      : Blockly.Blocks.texts.HUE,
            helpUrl     : Blockly.Msg.TEXT_COUNT_HELPURL,
            inputsInline: !0,
            message0    : Blockly.Msg.TEXT_COUNT_MESSAGE0,
            output      : "Number",
            tooltip     : Blockly.Msg.TEXT_COUNT_TOOLTIP
        })
    }
};
Blockly.Blocks.text_replace               = {
    init: function () {
        this.jsonInit({
            args0       : [
                {
                    check: "String",
                    name : "FROM",
                    type : "input_value"
                }, {
                    check: "String",
                    name : "TO",
                    type : "input_value"
                }, {
                    check: "String",
                    name : "TEXT",
                    type : "input_value"
                }
            ],
            colour      : Blockly.Blocks.texts.HUE,
            helpUrl     : Blockly.Msg.TEXT_REPLACE_HELPURL,
            inputsInline: !0,
            message0    : Blockly.Msg.TEXT_REPLACE_MESSAGE0,
            output      : "String",
            tooltip     : Blockly.Msg.TEXT_REPLACE_TOOLTIP
        })
    }
};
Blockly.Blocks.text_reverse               = {
    init: function () {
        this.jsonInit({
            args0       : [
                {
                    check: "String",
                    name : "TEXT",
                    type : "input_value"
                }
            ],
            colour      : Blockly.Blocks.texts.HUE,
            helpUrl     : Blockly.Msg.TEXT_REVERSE_HELPURL,
            inputsInline: !0,
            message0    : Blockly.Msg.TEXT_REVERSE_MESSAGE0,
            output      : "String",
            tooltip     : Blockly.Msg.TEXT_REVERSE_TOOLTIP
        })
    }
};
Blockly.Constants.Text.QUOTE_IMAGE_MIXIN  = {
    newQuote_                : function (a) {
        a = this.RTL
            ? !a
            : a;
        return new Blockly.FieldImage(
            a
                ? this.QUOTE_IMAGE_LEFT_DATAURI
                : this.QUOTE_IMAGE_RIGHT_DATAURI,
            this.QUOTE_IMAGE_WIDTH,
            this.QUOTE_IMAGE_HEIGHT,
            a
                ? "\u201c"
                : "\u201d"
        )
    },
    QUOTE_IMAGE_HEIGHT       : 12,
    QUOTE_IMAGE_LEFT_DATAURI : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI" +
            "1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7" +
            "EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8D" +
            "zvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC",
    QUOTE_IMAGE_RIGHT_DATAURI: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI" +
            "1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ" +
            "7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q9" +
            "9FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAA" +
            "BJRU5ErkJggg==",
    QUOTE_IMAGE_WIDTH        : 12,
    quoteField_              : function (a) {
        for (var b = 0, c; c = this.inputList[b]; b++) 
            for (var d = 0, e; e = c.fieldRow[d]; d++) 
                if (a == e.name) {
                    c.insertFieldAt(d, this.newQuote_(!0));
                    c.insertFieldAt(d + 2, this.newQuote_(!1));
                    return
                }
            console.warn('field named "' + a + '" not found in ' + this.toDevString())
    }
};
Blockly.Blocks.loops                      = {};
Blockly.Constants.Loops                   = {};
Blockly.Constants.Loops.HUE               = 120;
Blockly.Blocks.loops.HUE                  = Blockly.Constants.Loops.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0            : [
            {
                check: "Number",
                name : "TIMES",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        helpUrl          : "%{BKY_CONTROLS_REPEAT_HELPURL}",
        message0         : "%{BKY_CONTROLS_REPEAT_TITLE}",
        message1         : "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
        nextStatement    : null,
        previousStatement: null,
        tooltip          : "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
        type             : "controls_repeat_ext"
    }, {
        args0            : [
            {
                min      : 0,
                name     : "TIMES",
                precision: 1,
                type     : "field_number",
                value    : 10
            }
        ],
        args1            : [
            {
                name: "DO",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        helpUrl          : "%{BKY_CONTROLS_REPEAT_HELPURL}",
        message0         : "%{BKY_CONTROLS_REPEAT_TITLE}",
        message1         : "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
        nextStatement    : null,
        previousStatement: null,
        tooltip          : "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
        type             : "controls_repeat"
    }, {
        args0            : [
            {
                name   : "MODE",
                options: [
                    [
                        "%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_WHILE}", "WHILE"
                    ],
                    [
                        "%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL}", "UNTIL"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Boolean",
                name : "BOOL",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        extensions       : ["controls_whileUntil_tooltip"],
        helpUrl          : "%{BKY_CONTROLS_WHILEUNTIL_HELPURL}",
        message0         : "%1 %2",
        message1         : "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
        nextStatement    : null,
        previousStatement: null,
        type             : "controls_whileUntil"
    }, {
        args0            : [
            {
                name    : "VAR",
                type    : "field_variable",
                variable: null
            }, {
                align: "RIGHT",
                check: "Number",
                name : "FROM",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Number",
                name : "TO",
                type : "input_value"
            }, {
                align: "RIGHT",
                check: "Number",
                name : "BY",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        extensions       : [
            "contextMenu_newGetVariableBlock", "controls_for_tooltip"
        ],
        helpUrl          : "%{BKY_CONTROLS_FOR_HELPURL}",
        inputsInline     : !0,
        message0         : "%{BKY_CONTROLS_FOR_TITLE}",
        message1         : "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
        nextStatement    : null,
        previousStatement: null,
        type             : "controls_for"
    }, {
        args0            : [
            {
                name    : "VAR",
                type    : "field_variable",
                variable: null
            }, {
                check: "Array",
                name : "LIST",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        extensions       : [
            "contextMenu_newGetVariableBlock", "controls_forEach_tooltip"
        ],
        helpUrl          : "%{BKY_CONTROLS_FOREACH_HELPURL}",
        message0         : "%{BKY_CONTROLS_FOREACH_TITLE}",
        message1         : "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
        nextStatement    : null,
        previousStatement: null,
        type             : "controls_forEach"
    }, {
        args0            : [
            {
                name   : "FLOW",
                options: [
                    [
                        "%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK}", "BREAK"
                    ],
                    [
                        "%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE}", "CONTINUE"
                    ]
                ],
                type   : "field_dropdown"
            }
        ],
        colour           : "%{BKY_LOOPS_HUE}",
        extensions       : [
            "controls_flow_tooltip", "controls_flow_in_loop_check"
        ],
        helpUrl          : "%{BKY_CONTROLS_FLOW_STATEMENTS_HELPURL}",
        message0         : "%1",
        previousStatement: null,
        type             : "controls_flow_statements"
    }
]);
Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS = {
    UNTIL: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL}",
    WHILE: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_WHILE}"
};
Blockly
    .Extensions
    .register(
        "controls_whileUntil_tooltip",
        Blockly.Extensions.buildTooltipForDropdown("MODE", Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS)
    );
Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS = {
    BREAK   : "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK}",
    CONTINUE: "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE}"
};
Blockly
    .Extensions
    .register(
        "controls_flow_tooltip",
        Blockly.Extensions.buildTooltipForDropdown("FLOW", Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS)
    );
Blockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN = {
    customContextMenu: function (a) {
        var b = this.getFieldValue("VAR");
        if (!this.isCollapsed() && null != b) {
            var c = {
                enabled: !0
            };
            c.text = Blockly
                .Msg
                .VARIABLES_SET_CREATE_GET
                .replace("%1", b);
            b      = goog
                .dom
                .createDom("field", null, b);
            b.setAttribute("name", "VAR");
            b = goog
                .dom
                .createDom("block", null, b);
            b.setAttribute("type", "variables_get");
            c.callback = Blockly
                .ContextMenu
                .callbackFactory(this, b);
            a.push(c)
        }
    }
};
Blockly
    .Extensions
    .registerMixin(
        "contextMenu_newGetVariableBlock",
        Blockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN
    );
Blockly
    .Extensions
    .register(
        "controls_for_tooltip",
        Blockly.Extensions.buildTooltipWithFieldValue(Blockly.Msg.CONTROLS_FOR_TOOLTIP, "VAR")
    );
Blockly
    .Extensions
    .register(
        "controls_forEach_tooltip",
        Blockly.Extensions.buildTooltipWithFieldValue(Blockly.Msg.CONTROLS_FOREACH_TOOLTIP, "VAR")
    );
Blockly.Constants.Loops.CONTROL_FLOW_CHECK_IN_LOOP_MIXIN = {
    LOOP_TYPES: [
        "controls_repeat", "controls_repeat_ext", "controls_forEach", "controls_for", "controls_whileUntil"
    ],
    onchange  : function () {
        if (this.workspace.isDragging && !this.workspace.isDragging()) {
            var a = !1,
                b = this;
            do {
                if (-1 != this.LOOP_TYPES.indexOf(b.type)) {
                    a = !0;
                    break
                }
                b = b.getSurroundParent()
            } while (b);
            a
                ? (this.setWarningText(null), this.isInFlyout || this.setDisabled(!1))
                : (
                    this.setWarningText(Blockly.Msg.CONTROLS_FLOW_STATEMENTS_WARNING),
                    this.isInFlyout || this.getInheritedDisabled() || this.setDisabled(!0)
                )
        }
    }
};
Blockly
    .Extensions
    .registerMixin(
        "controls_flow_in_loop_check",
        Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN
    );
Blockly.Blocks.logic        = {};
Blockly.Constants.Logic     = {};
Blockly.Constants.Logic.HUE = 210;
Blockly.Blocks.logic.HUE    = Blockly.Constants.Logic.HUE;
Blockly.defineBlocksWithJsonArray([
    {
        args0   : [
            {
                name   : "BOOL",
                options: [
                    [
                        "%{BKY_LOGIC_BOOLEAN_TRUE}", "TRUE"
                    ],
                    [
                        "%{BKY_LOGIC_BOOLEAN_FALSE}", "FALSE"
                    ]
                ],
                type   : "field_dropdown"
            }
        ],
        colour  : "%{BKY_LOGIC_HUE}",
        helpUrl : "%{BKY_LOGIC_BOOLEAN_HELPURL}",
        message0: "%1",
        output  : "Boolean",
        tooltip : "%{BKY_LOGIC_BOOLEAN_TOOLTIP}",
        type    : "logic_boolean"
    }, {
        args0            : [
            {
                check: "Boolean",
                name : "IF0",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO0",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOGIC_HUE}",
        extensions       : ["controls_if_tooltip"],
        helpUrl          : "%{BKY_CONTROLS_IF_HELPURL}",
        message0         : "%{BKY_CONTROLS_IF_MSG_IF} %1",
        message1         : "%{BKY_CONTROLS_IF_MSG_THEN} %1",
        mutator          : "controls_if_mutator",
        nextStatement    : null,
        previousStatement: null,
        type             : "controls_if"
    }, {
        args0            : [
            {
                check: "Boolean",
                name : "IF0",
                type : "input_value"
            }
        ],
        args1            : [
            {
                name: "DO0",
                type: "input_statement"
            }
        ],
        args2            : [
            {
                name: "ELSE",
                type: "input_statement"
            }
        ],
        colour           : "%{BKY_LOGIC_HUE}",
        extensions       : ["controls_if_tooltip"],
        helpUrl          : "%{BKY_CONTROLS_IF_HELPURL}",
        message0         : "%{BKY_CONTROLS_IF_MSG_IF} %1",
        message1         : "%{BKY_CONTROLS_IF_MSG_THEN} %1",
        message2         : "%{BKY_CONTROLS_IF_MSG_ELSE} %1",
        nextStatement    : null,
        previousStatement: null,
        tooltip          : "%{BKYCONTROLS_IF_TOOLTIP_2}",
        type             : "controls_ifelse"
    }, {
        args0       : [
            {
                name: "A",
                type: "input_value"
            }, {
                name   : "OP",
                options: [
                    [
                        "=", "EQ"
                    ],
                    [
                        "\u2260", "NEQ"
                    ],
                    [
                        "<", "LT"
                    ],
                    [
                        "\u2264", "LTE"
                    ],
                    [
                        ">", "GT"
                    ],
                    [
                        "\u2265", "GTE"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                name: "B",
                type: "input_value"
            }
        ],
        colour      : "%{BKY_LOGIC_HUE}",
        extensions  : [
            "logic_compare", "logic_op_tooltip"
        ],
        helpUrl     : "%{BKY_LOGIC_COMPARE_HELPURL}",
        inputsInline: !0,
        message0    : "%1 %2 %3",
        output      : "Boolean",
        type        : "logic_compare"
    }, {
        args0       : [
            {
                check: "Boolean",
                name : "A",
                type : "input_value"
            }, {
                name   : "OP",
                options: [
                    [
                        "%{BKY_LOGIC_OPERATION_AND}", "AND"
                    ],
                    [
                        "%{BKY_LOGIC_OPERATION_OR}", "OR"
                    ]
                ],
                type   : "field_dropdown"
            }, {
                check: "Boolean",
                name : "B",
                type : "input_value"
            }
        ],
        colour      : "%{BKY_LOGIC_HUE}",
        extensions  : ["logic_op_tooltip"],
        helpUrl     : "%{BKY_LOGIC_OPERATION_HELPURL}",
        inputsInline: !0,
        message0    : "%1 %2 %3",
        output      : "Boolean",
        type        : "logic_operation"
    }, {
        args0   : [
            {
                check: "Boolean",
                name : "BOOL",
                type : "input_value"
            }
        ],
        colour  : "%{BKY_LOGIC_HUE}",
        helpUrl : "%{BKY_LOGIC_NEGATE_HELPURL}",
        message0: "%{BKY_LOGIC_NEGATE_TITLE}",
        output  : "Boolean",
        tooltip : "%{BKY_LOGIC_NEGATE_TOOLTIP}",
        type    : "logic_negate"
    }, {
        colour  : "%{BKY_LOGIC_HUE}",
        helpUrl : "%{BKY_LOGIC_NULL_HELPURL}",
        message0: "%{BKY_LOGIC_NULL}",
        output  : null,
        tooltip : "%{BKY_LOGIC_NULL_TOOLTIP}",
        type    : "logic_null"
    }, {
        args0     : [
            {
                check: "Boolean",
                name : "IF",
                type : "input_value"
            }
        ],
        args1     : [
            {
                name: "THEN",
                type: "input_value"
            }
        ],
        args2     : [
            {
                name: "ELSE",
                type: "input_value"
            }
        ],
        colour    : "%{BKY_LOGIC_HUE}",
        extensions: ["logic_ternary"],
        helpUrl   : "%{BKY_LOGIC_TERNARY_HELPURL}",
        message0  : "%{BKY_LOGIC_TERNARY_CONDITION} %1",
        message1  : "%{BKY_LOGIC_TERNARY_IF_TRUE} %1",
        message2  : "%{BKY_LOGIC_TERNARY_IF_FALSE} %1",
        output    : null,
        tooltip   : "%{BKY_LOGIC_TERNARY_TOOLTIP}",
        type      : "logic_ternary"
    }
]);
Blockly.defineBlocksWithJsonArray([
    {
        colour           : "%{BKY_LOGIC_HUE}",
        enableContextMenu: !1,
        message0         : "%{BKY_CONTROLS_IF_IF_TITLE_IF}",
        nextStatement    : null,
        tooltip          : "%{BKY_CONTROLS_IF_IF_TOOLTIP}",
        type             : "controls_if_if"
    }, {
        colour           : "%{BKY_LOGIC_HUE}",
        enableContextMenu: !1,
        message0         : "%{BKY_CONTROLS_IF_ELSEIF_TITLE_ELSEIF}",
        nextStatement    : null,
        previousStatement: null,
        tooltip          : "%{BKY_CONTROLS_IF_ELSEIF_TOOLTIP}",
        type             : "controls_if_elseif"
    }, {
        colour           : "%{BKY_LOGIC_HUE}",
        enableContextMenu: !1,
        message0         : "%{BKY_CONTROLS_IF_ELSE_TITLE_ELSE}",
        previousStatement: null,
        tooltip          : "%{BKY_CONTROLS_IF_ELSE_TOOLTIP}",
        type             : "controls_if_else"
    }
]);
Blockly.Constants.Logic.TOOLTIPS_BY_OP = {
    AND: "%{BKY_LOGIC_OPERATION_TOOLTIP_AND}",
    EQ : "%{BKY_LOGIC_COMPARE_TOOLTIP_EQ}",
    GT : "%{BKY_LOGIC_COMPARE_TOOLTIP_GT}",
    GTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_GTE}",
    LT : "%{BKY_LOGIC_COMPARE_TOOLTIP_LT}",
    LTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_LTE}",
    NEQ: "%{BKY_LOGIC_COMPARE_TOOLTIP_NEQ}",
    OR : "%{BKY_LOGIC_OPERATION_TOOLTIP_OR}"
};
Blockly
    .Extensions
    .register(
        "logic_op_tooltip",
        Blockly.Extensions.buildTooltipForDropdown("OP", Blockly.Constants.Logic.TOOLTIPS_BY_OP)
    );
Blockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN = {
    compose        : function (a) {
        var b = a
            .nextConnection
            .targetBlock();
        this.elseCount_ = this.elseifCount_ = 0;
        a               = [null];
        for (var c = [null], d = null; b;) {
            switch (b.type) {
                case "controls_if_elseif":
                    this.elseifCount_++;
                    a.push(b.valueConnection_);
                    c.push(b.statementConnection_);
                    break;
                case "controls_if_else":
                    this.elseCount_++;
                    d = b.statementConnection_;
                    break;
                default:
                    throw "Unknown block type.";
            }
            b = b.nextConnection && b
                .nextConnection
                .targetBlock()
        }
        this.updateShape_();
        for (b = 1; b <= this.elseifCount_; b++) 
            Blockly
                .Mutator
                .reconnect(a[b], this, "IF" + b),
            Blockly
                .Mutator
                .reconnect(c[b], this, "DO" + b);
        Blockly
            .Mutator
            .reconnect(d, this, "ELSE")
    },
    decompose      : function (a) {
        var b = a.newBlock("controls_if_if");
        b.initSvg();
        for (var c = b.nextConnection, d = 1; d <= this.elseifCount_; d++) {
            var e = a.newBlock("controls_if_elseif");
            e.initSvg();
            c.connect(e.previousConnection);
            c = e.nextConnection
        }
        this.elseCount_ && (
            a = a.newBlock("controls_if_else"),
            a.initSvg(),
            c.connect(a.previousConnection)
        );
        return b
    },
    domToMutation  : function (a) {
        this.elseifCount_ = parseInt(a.getAttribute("elseif"), 10) || 0;
        this.elseCount_   = parseInt(a.getAttribute("else"), 10) || 0;
        this.updateShape_()
    },
    elseCount_     : 0,
    elseifCount_   : 0,
    mutationToDom  : function () {
        if (!this.elseifCount_ && !this.elseCount_) 
            return null;
        var a = document.createElement("mutation");
        this.elseifCount_ && a.setAttribute("elseif", this.elseifCount_);
        this.elseCount_ && a.setAttribute("else", 1);
        return a
    },
    saveConnections: function (a) {
        a = a
            .nextConnection
            .targetBlock();
        for (var b = 1; a;) {
            switch (a.type) {
                case "controls_if_elseif":
                    var c = this.getInput("IF" + b),
                        d = this.getInput("DO" + b);
                    a.valueConnection_     = c && c.connection.targetConnection;
                    a.statementConnection_ = d && d.connection.targetConnection;
                    b++;
                    break;
                case "controls_if_else":
                    d                      = this.getInput("ELSE");
                    a.statementConnection_ = d && d.connection.targetConnection;
                    break;
                default:
                    throw "Unknown block type.";
            }
            a = a.nextConnection && a
                .nextConnection
                .targetBlock()
        }
    },
    updateShape_   : function () {
        this.getInput("ELSE") && this.removeInput("ELSE");
        for (var a = 1; this.getInput("IF" + a);) 
            this.removeInput("IF" + a),
            this.removeInput("DO" + a),
            a++;
        for (a = 1; a <= this.elseifCount_; a++) 
            this
                .appendValueInput("IF" + a)
                .setCheck("Boolean")
                .appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSEIF),
            this
                .appendStatementInput("DO" + a)
                .appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);
        this.elseCount_ && this
            .appendStatementInput("ELSE")
            .appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSE)
    }
};
Blockly
    .Extensions
    .registerMutator(
        "controls_if_mutator",
        Blockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN,
        null,
        ["controls_if_elseif", "controls_if_else"]
    );
Blockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION = function () {
    this.setTooltip(function () {
        if (this.elseifCount_ || this.elseCount_) {
            if (!this.elseifCount_ && this.elseCount_) 
                return Blockly.Msg.CONTROLS_IF_TOOLTIP_2;
            if (this.elseifCount_ && !this.elseCount_) 
                return Blockly.Msg.CONTROLS_IF_TOOLTIP_3;
            if (this.elseifCount_ && this.elseCount_) 
                return Blockly.Msg.CONTROLS_IF_TOOLTIP_4
        } else 
            return Blockly.Msg.CONTROLS_IF_TOOLTIP_1;
        return ""
    }.bind(this))
};
Blockly
    .Extensions
    .register(
        "controls_if_tooltip",
        Blockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION
    );
Blockly.Constants.Logic.fixLogicCompareRtlOpLabels   = function () {
    var a = {
            GT : "\u200f>\u200f",
            GTE: "\u200f\u2265\u200f",
            LT : "\u200f<\u200f",
            LTE: "\u200f\u2264\u200f"
        },
        b = this.getField("OP");
    if (b) 
        for (var b = b.getOptions(), c = 0; c < b.length; ++c) {
            var d = b[c],
                e = a[d[1]];
            goog.isString(d[0]) && e && (d[0] = e)
        }
    };
Blockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN = {
    onchange   : function (a) {
        var b = this.getInputTargetBlock("A"),
            c = this.getInputTargetBlock("B");
        if (b && c && !b.outputConnection.checkType_(c.outputConnection)) {
            Blockly
                .Events
                .setGroup(a.group);
            for (a = 0; a < this.prevBlocks_.length; a++) {
                var d = this.prevBlocks_[a];
                if (d === b || d === c) 
                    d.unplug(),
                    d.bumpNeighbours_()
            }
            Blockly
                .Events
                .setGroup(!1)
        }
        this.prevBlocks_[0] = b;
        this.prevBlocks_[1] = c
    },
    prevBlocks_: [null, null]
};
Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION      = function () {
    this.RTL && Blockly
        .Constants
        .Logic
        .fixLogicCompareRtlOpLabels
        .apply(this);
    this.mixin(Blockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN)
};
Blockly
    .Extensions
    .register("logic_compare", Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION);
Blockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN = {
    onchange             : function (a) {
        var b = this.getInputTargetBlock("THEN"),
            c = this.getInputTargetBlock("ELSE"),
            d = this.outputConnection.targetConnection;
        if ((b || c) && d) 
            for (var e = 0; 2 > e; e++) {
                var f = 1 == e
                    ? b
                    : c;
                f && !f
                    .outputConnection
                    .checkType_(d) && (
                        Blockly.Events.setGroup(a.group),
                        d === this.prevParentConnection_
                            ? (this.unplug(), d.getSourceBlock().bumpNeighbours_())
                            : (f.unplug(), f.bumpNeighbours_()),
                        Blockly.Events.setGroup(!1)
                    )
            }
        this.prevParentConnection_ = d
    },
    prevParentConnection_: null
};
Blockly
    .Extensions
    .registerMixin(
        "logic_ternary",
        Blockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN
    );